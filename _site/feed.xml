<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-15T21:32:58+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">密碼龐克 Cypherpunks Taiwan</title><subtitle>密碼學使自由和隱私再次偉大。Cryptography makes freedom and privacy great again.</subtitle><entry><title type="html">BIP-65 OP_CHECKLOCKTIMEVERIFY</title><link href="http://localhost:4000/news/2019/11/14/BIP-65-OP_CHECKLOCKTIMEVERIFY/" rel="alternate" type="text/html" title="BIP-65 OP_CHECKLOCKTIMEVERIFY" /><published>2019-11-14T00:00:00+08:00</published><updated>2019-11-14T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/14/BIP-65%20OP_CHECKLOCKTIMEVERIFY</id><content type="html" xml:base="http://localhost:4000/news/2019/11/14/BIP-65-OP_CHECKLOCKTIMEVERIFY/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-65%20OP-CHECKLOCKTIMEVERIFY.html&quot;&gt;原文&lt;/a&gt;:BIP-65 OP_CHECKLOCKTIMEVERIFY    &lt;br /&gt;
該BIP為比特幣 script 系統描述了一個新的 OPCode （&lt;code class=&quot;highlighter-rouge&quot;&gt;OP_CHECKLOCKTIMEVERIFY&lt;/code&gt;），該 OPCode 允許交易輸出在未來的某個點之前變得不可花費。&lt;/p&gt;

&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CHECKLOCKTIMEVERIFY 重新定義了現有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP2&lt;/code&gt; OPCode (其實就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_CHECKLOCKTIMEVERIFY&lt;/code&gt; 指令替換了 &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_NOP2&lt;/code&gt; 指令)。執行時，如果以下任何一個條件成立，則 OPCode 直譯器將以錯誤終止：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;堆棧是空的;&lt;/li&gt;
  &lt;li&gt;堆棧中的頂層項目小於0;&lt;/li&gt;
  &lt;li&gt;頂層堆棧項的鎖定時間類型（高度vs.時間戳）與 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位不同;&lt;/li&gt;
  &lt;li&gt;頂部堆棧項大於交易的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;txin&lt;/code&gt;（交易輸入）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nSequence&lt;/code&gt; 欄位是 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否則， OPCode 執行將繼續，如同NOP執行一樣。&lt;/p&gt;

&lt;p&gt;交易中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位可防止交易被挖出，直到達到某個區塊高度或區塊時間為止。通過將傳給 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 的參數與 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位進行比較，我們間接驗證是否已達到所需的區塊高度或區塊時間; 直到該區塊高度或區塊時間已經達到，交易輸出仍然不可花費。&lt;/p&gt;

&lt;h2 id=&quot;動機&quot;&gt;動機&lt;/h2&gt;

&lt;p&gt;交易中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位可用於證明 將來可以花費這筆交易輸出，方法是構造一個有效的交易開銷，並對&lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt;欄位進行設定。&lt;/p&gt;

&lt;p&gt;然而， &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位不能證明在未來的某個時間內不可能花費交易輸出，因為無法知道是否建立了支出該輸出的其他交易的有效簽名。&lt;/p&gt;

&lt;h2 id=&quot;第三方託管&quot;&gt;第三方託管&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果 Alice 和 Bob 聯合經營一家企業，他們可能希望確保所有資金都儲存在需要雙方同時批准的 2-of-2 的多重（多重簽名的交易）交易輸出中。但是，他們發現在特殊情況下，例如任何一個人受到“嚴重的車禍”，他們都需要備用的方法，繼續動用該筆資金。因此，他們任命他們的律師 Lenny 擔任第三方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在任何時候，Lenny 隨時可以同 Alice 或 Bob 一起串謀非法竊取資金。同樣，Lenny 可能更願意不竊取資金，以阻止不良行為者企圖強行從他那裡獲取 secret keys 。&lt;/p&gt;

&lt;p&gt;但是，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可以將資金儲存在以下格式的 scriptPubKeys 中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    &amp;lt;now + 3 months&amp;gt; CHECKLOCKTIMEVERIFY DROP
    &amp;lt;Lenny's pubkey&amp;gt; CHECKSIGVERIFY
    1
ELSE
    2
ENDIF
&amp;lt;Alice's pubkey&amp;gt; &amp;lt;Bob's pubkey&amp;gt; 2 CHECKMULTISIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在任何時候，資金都可以用下面的 OPCode 來支付：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 &amp;lt;Alice's signature&amp;gt; &amp;lt;Bob's signature&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lenny 經過 3 個月後，Alice 或 Bob 中的一個可以用以下 OPCode 支付資金：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 &amp;lt;Alice/Bob's signature&amp;gt; &amp;lt;Lenny's signature&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;非交互式定期退款--non-interactive-time-locked-refunds&quot;&gt;非交互式定期退款 | Non-interactive time-locked refunds&lt;/h2&gt;

&lt;p&gt;存在許多協議，其中建立交易輸出，這需要雙方的合作來花費輸出。為確保一方的失敗不會導致資金損失，退款交易使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 提前設定。這些退款交易需要互動式建立，此外，目前易受交易延展性影響。 ` CHECKLOCKTIMEVERIFY` 可用於這些協議，用非互動式設定取代互動式設定，另外，使交易延展性不成問題。&lt;/p&gt;

&lt;h3 id=&quot;雙因素錢包--two-factor-wallets&quot;&gt;雙因素錢包 | Two-factor wallets&lt;/h3&gt;

&lt;p&gt;諸如 GreenAddress 之類的服務將比特幣儲存為 2-of-2 的多重簽名 OPCode ScriptPubKey，使得一個金鑰對由使用者控制，另一個金鑰對由服務控制。為了花費資金，使用者使用本地安裝的生成所需簽名之一的錢包軟體，然後使用雙因素身份驗證方法來授權該服務建立第二個 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHASH_NONE&lt;/code&gt; 簽名，該簽名在將來的某個時間被鎖定，並向用戶傳送該儲存簽名。如果使用者需要花費資金並且服務不可用，他們會等到 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 過期。&lt;/p&gt;

&lt;p&gt;問題是，在許多情況下，使用者將不會擁有一些或全部交易輸出的有效簽名。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 而不是按需建立退款簽名，而是使用以下形式的 scriptPubKeys ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    &amp;lt;service pubkey&amp;gt; CHECKSIGVERIFY
ELSE
    &amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP
ENDIF
&amp;lt;user pubkey&amp;gt; CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現在，用戶總是可以通過等待到期時間來花費他們的資金而無需服務的合作。&lt;/p&gt;

&lt;h3 id=&quot;支付通道--payment-channels&quot;&gt;支付通道 | Payment Channels&lt;/h3&gt;

&lt;p&gt;傑里米·斯皮爾曼（ Jeremy Spilman ）style 的支付通道首先設定一個存款，由 2-of-2 的多重簽名， tx1 控制的存款，然後調整第二個交易 tx2 ，將 tx1 的輸出用於支付者和收款者。在釋出 tx1 之前，建立一個退款交易 tx3 ，確保收款人消失時付款人可以取回其押金。當前創建退款交易的過程容易受到交易延展性攻擊的影響，此外，還要求付款人儲存退款。使用與雙因素錢包示例中相同的 scriptPubKey 形式可以解決這兩個問題。&lt;/p&gt;

&lt;h2 id=&quot;發布數據的無信任付款--trustless-payments-for-publishing-data&quot;&gt;發布數據的無信任付款 | Trustless Payments for Publishing Data&lt;/h2&gt;

&lt;p&gt;The PayPub protocol makes it possible to pay for information in a trustless way by first proving that an encrypted file contains the desired data, and secondly crafting scriptPubKeys used for payment such that spending them reveals the encryption keys to the data. However the existing implementation has a significant flaw: the publisher can delay the release of the keys indefinitely.&lt;/p&gt;

&lt;p&gt;This problem can be solved interactively with the refund transaction technique; with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using scriptPubKeys of the following form:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;通過首先證明加密文件包含所需的數據，然後製作用於支付的 scriptPubKeys 以便使它們花費來顯示數據的加密密鑰，PayPub 協議可以以不信任的方式支付信息。但是，現有的實現存在一個重大缺陷：發布者可以無限期地延遲密鑰的發布。&lt;/p&gt;

&lt;p&gt;這個問題可以用退款交易技術互動地解決; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; ，可以使用以下形式的scriptPubKeys以非互動方式解決問題：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    HASH160 &amp;lt;Hash160(encryption key)&amp;gt; EQUALVERIFY
    &amp;lt;publisher pubkey&amp;gt; CHECKSIG
ELSE
    &amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP
    &amp;lt;buyer pubkey&amp;gt; CHECKSIG
ENDIF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;資料的買家現在正在提供一個有效期限的安全報價。如果發行商在到期時間到期之前未能接受報價，買家可以通過消費輸出來取消報價。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;證明犧牲礦工的手續費--proving-sacrifice-to-miners-fees&quot;&gt;證明犧牲礦工的手續費 | Proving sacrifice to miners’ fees&lt;/h2&gt;

&lt;p&gt;Proving the sacrifice of some limited resource is a common technique in a variety of cryptographic protocols. Proving sacrifices of coins to mining fees has been proposed as a universal public good to which the sacrifice could be directed, rather than simply destroying the coins. However doing so is non-trivial, and even the best existing technqiue - announce-commit sacrifices - could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to create outputs that are provably spendable by anyone (thus to mining fees assuming miners behave optimally and rationally) but only at a time sufficiently far into the future that large miners can’t profitably sell the sacrifices at a discount.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;證明犧牲一些有限的資源是各種密碼協議中的常用技術。已經提出了證明將硬幣犧牲為採礦費的做法，作為犧牲品可以針對的一種普遍的公共物品，而不是簡單地銷毀硬幣。但是，這樣做並非易事，即使是現有的最佳技術-宣布承諾犧牲-也會鼓勵採礦業的集中化。  &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可用於創建任何人都可證明可使用的輸出（因此，假設礦工的行為合理且合理，則要收取採礦費），但前提是在足夠遠的將來，大型礦工無法以折扣價出售利潤。&lt;/p&gt;

&lt;p&gt;證明犧牲一些有限的資源是各種密碼協議中的常見技術。已經提出將幣的犧牲證明為挖礦手續費，作為犧牲可以指向的普遍公共物品，而不是簡單地摧毀幣。然而，這樣做並非微不足道，即使是最好的現有技術 - 宣佈 - 承諾 - 也會鼓勵礦業集中。 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可用於建立任何人都可以花費的產出（因此，假設礦工的行為是理想的和理性的，那麼開採費），但只有在未來足夠遠的時間，大型礦工才能以折扣銷售犧牲品。&lt;/p&gt;

&lt;h2 id=&quot;凍結資金--freezing-funds&quot;&gt;凍結資金 | Freezing Funds&lt;/h2&gt;

&lt;p&gt;除了使用冷儲存，硬體錢包和 P2SH multisig 輸出來控制資金之外，現在資金可以直接在區塊鏈中凍結在 UTXO 中。使用下面的 scriptPubKey ，在提供的失效時間之前，沒有人能夠使用安全輸出。這種可靠地凍結資金的能力在需要減少脅迫或沒收風險的情況下可能會有用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &amp;lt;pubKeyHash&amp;gt; EQUALVERIFY CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;完全替換nlocktime欄位--replacing-the-nlocktime-field-entirely&quot;&gt;完全替換nLockTime欄位 | Replacing the nLockTime field entirely&lt;/h2&gt;

&lt;p&gt;另外，請注意如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;SignatureHash()&lt;/code&gt; 演算法可以選擇覆蓋 OPCode 的一部分，那麼簽名可能會要求 OPCode Sig包含&lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; OPCode ，並且還需要執行它們。（ CODESEPARATOR OPCode 非常接近於在比特幣的 v0.1 中實現這一點）。這種每簽名功能可以完全取代每個交易的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位，因為有效簽名現在可以證明交易輸出可以花費。&lt;/p&gt;

&lt;h2 id=&quot;詳細規格--detailed-specification&quot;&gt;詳細規格 | Detailed Specification&lt;/h2&gt;

&lt;p&gt;參考下面轉載的參考實現，瞭解這些語義的精確語義和詳細基本原理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case OP_NOP2:
case OP_NOP2:
{
    // CHECKLOCKTIMEVERIFY
    //
    // (nLockTime -- nLockTime )

    if (!(flags &amp;amp; SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))
        break; // not enabled; treat as a NOP

    if (stack.size() &amp;lt; 1)
        return false;

    // Note that elsewhere numeric opcodes are limited to
    // operands in the range -2**31+1 to 2**31-1, however it is
    // legal for opcodes to produce results exceeding that
    // range. This limitation is implemented by CScriptNum's
    // default 4-byte limit.
    //
    // If we kept to that limit we'd have a year 2038 problem,
    // even though the nLockTime field in transactions
    // themselves is uint32 which only becomes meaningless
    // after the year 2106.
    //
    // Thus as a special case we tell CScriptNum to accept up
    // to 5-byte bignums, which are good until 2**32-1, the
    // same limit as the nLockTime field itself.
    const CScriptNum nLockTime(stacktop(-1), 5);

    // In the rare event that the argument may be &amp;lt; 0 due to
    // some arithmetic being done first, you can always use
    // 0 MAX CHECKLOCKTIMEVERIFY.
    if (nLockTime &amp;lt; 0)
        return false;

    // There are two types of nLockTime: lock-by-blockheight
    // and lock-by-blocktime, distinguished by whether
    // nLockTime &amp;lt; LOCKTIME_THRESHOLD.
    //
    // We want to compare apples to apples, so fail the script
    // unless the type of nLockTime being tested is the same as
    // the nLockTime in the transaction.
    if (!(
            (txTo.nLockTime &amp;lt;  LOCKTIME_THRESHOLD &amp;amp;&amp;amp; nLockTime &amp;lt;  LOCKTIME_THRESHOLD) ||
            (txTo.nLockTime &amp;gt;= LOCKTIME_THRESHOLD &amp;amp;&amp;amp; nLockTime &amp;gt;= LOCKTIME_THRESHOLD)
            ))
        return false;

    // Now that we know we're comparing apples-to-apples, the
    // comparison is a simple numeric one.
    if (nLockTime &amp;gt; (int64_t)txTo.nLockTime)
        return false;

    // Finally the nLockTime feature can be disabled and thus
    // CHECKLOCKTIMEVERIFY bypassed if every txin has been
    // finalized by setting nSequence to maxint. The
    // transaction would be allowed into the blockchain, making
    // the opcode ineffective.
    //
    // Testing if this vin is not final is sufficient to
    // prevent this condition. Alternatively we could test all
    // inputs, but testing just this input minimizes the data
    // required to prove correct CHECKLOCKTIMEVERIFY execution.
    if (txTo.vin[nIn].IsFinal())
        return false;

    break;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4&lt;/p&gt;

&lt;h2 id=&quot;部署--deployment&quot;&gt;部署 | Deployment&lt;/h2&gt;

&lt;p&gt;我們重用BIP66中使用的雙閾值 &lt;code class=&quot;highlighter-rouge&quot;&gt;IsSuperMajority()&lt;/code&gt; 切換機制，其閾值相同，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion = 4&lt;/code&gt; 。新規則對於 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion = 4&lt;/code&gt; 的每個區塊（高度為H）有效，並且至少有750之前的區塊（高度為H-1000..H-1）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; 。此外，當區塊之前的1000個區塊中的950個具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; 時， &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;lt; 4&lt;/code&gt; 區塊將變為無效，並且全部進一步的阻止執行新的規則。&lt;/p&gt;

&lt;p&gt;應該注意的是，BIP9涉及永久性地將高位設定為1，這導致 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&amp;gt;=&lt;/code&gt; 所有先前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;IsSuperMajority()&lt;/code&gt; 軟分叉，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; 中的位不會永久丟失。&lt;/p&gt;

&lt;h2 id=&quot;spv客戶--spv-clients&quot;&gt;SPV客戶 | SPV Clients&lt;/h2&gt;

&lt;p&gt;儘管SPV客戶端（當前）通常無法驗證區塊，而是信任礦工對其進行驗證，但他們能夠驗證區塊頭，因此可以驗證部署規則的子集。如果達到95％閾值時，前1000個區塊中的950個中有950個具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; ，則SPV客戶端應拒絕 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion 4&lt;/code&gt; 區塊，以防止來自剩餘未升級礦工的5％的錯誤確認。&lt;/p&gt;

&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;
&lt;p&gt;Thanks goes to Gregory Maxwell for suggesting that the argument be compared against the per-transaction nLockTime, rather than the current block height and time.&lt;/p&gt;

&lt;h2 id=&quot;參考&quot;&gt;參考&lt;/h2&gt;

&lt;p&gt;PayPub&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/unsystem/paypub&quot;&gt;https://github.com/unsystem/paypub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeremy Spilman支付通道&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html&quot;&gt;https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;實現&quot;&gt;實現&lt;/h2&gt;

&lt;p&gt;Python / python-bitcoinlib&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/petertodd/checklocktimeverify-demos&quot;&gt;https://github.com/petertodd/checklocktimeverify-demos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript / Node.js / bitcore&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mruddy/bip65-demos&quot;&gt;https://github.com/mruddy/bip65-demos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;版權--copyright&quot;&gt;版權 | Copyright&lt;/h2&gt;

&lt;p&gt;This document is placed in the public domain.&lt;/p&gt;

&lt;h2 id=&quot;引用和參考&quot;&gt;引用和參考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chidaolian.com/article-680-4&quot;&gt;BIP65：檢查鎖定時間驗證&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki&quot;&gt;bips/bip-0065.mediawiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文:BIP-65 OP_CHECKLOCKTIMEVERIFY 該BIP為比特幣 script 系統描述了一個新的 OPCode （OP_CHECKLOCKTIMEVERIFY），該 OPCode 允許交易輸出在未來的某個點之前變得不可花費。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/135.jpg" /></entry><entry><title type="html">基於數位浮水印和區塊鏈的版權管理系統設計方案</title><link href="http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF-%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88/" rel="alternate" type="text/html" title="基於數位浮水印和區塊鏈的版權管理系統設計方案" /><published>2019-11-13T00:00:00+08:00</published><updated>2019-11-13T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF:%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88</id><content type="html" xml:base="http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF-%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88/">&lt;blockquote&gt;
  &lt;p&gt;本篇文章翻譯自 &lt;a href=&quot;https://ieeexplore-ieee-org.autorpa.lib.nkust.edu.tw/document/8377886/references#references&quot;&gt;Design Scheme of Copyright Management System Based on Digital Watermarking and Blockchain&lt;/a&gt; 的內容，數位浮水印概念我們從圖像、影像..等，已經玩了許久當他結合區塊鏈又會產生什麼火花呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;摘要&quot;&gt;摘要:&lt;/h1&gt;

&lt;p&gt;過去，基於數位浮水印的數位版權保護系統主要在改進演算法效率上，而忽略浮水印訊息的生成和儲存空間。在本論文提出一個全新且基於數位浮水印和訊息的區塊鏈版權管理系統之設計機制，它結合數位浮水印、區塊鏈、感知雜湊、QR code 和星際檔案系統（IPFS）。其中，區塊鏈用於安全儲存浮水印訊息，並為多個浮水印（多個版權）提供時間戳認證，以確認創建順序。感知雜湊用於基於圖像的結構信息生成雜湊，無需原始圖像即可確認浮水印訊息。QR code 用於生成包含圖像之雜湊和版權訊息作為浮水印圖像的 QR Code，以提高數位浮水印的強韌性和容量；IPFS 在沒中心伺服器的情況下儲存和分散浮水印的圖像。該機制可以增強數位浮水印技術在版權保護領域的有效性。透過這種方式，可以使用 P2P 網路來集成並完成版權管理和版權作品的出版，而無需受信任的第三方。節點依靠密碼學來確認彼此的身份並確保訊息之安全性。它可以減少訊息洩露，數據破壞和造成過去的集中式系統崩潰等風險。這提高了訊息的安全性和透明度，並加快了受版權保護作品的出版，以促進網路中的流通。該方案還可以改善多個創作之版權保護。結合區塊鏈和多個數位浮水印，在創作過程中記錄每個版權所有者的版權訊息並充分證明，為了保護每個版權所有者的合法權益。&lt;/p&gt;

&lt;h1 id=&quot;第一章節---介紹&quot;&gt;第一章節 - 介紹&lt;/h1&gt;

&lt;p&gt;隨著數位科技和互聯網之發展，以圖像、音頻、影像和其他數位格式的多媒體和數位作品已經在互聯網上發布，其版權保護和訊息完整性保證已逐漸成為迫切需要解決的問題。由於數位作品易於複製、處理、傳播和公開，因此竊盜者利用數位作品的這些特徵破壞版權擁有者的合法權利以獲得個人利益。&lt;/p&gt;

&lt;p&gt;數位浮水印技術可用於數位版權之保護 [1] [2] [3]。它可以將一些重要機密訊息（例如版權所有者的個人信息）添加到數位作品中，且不會被數位作品使用者察覺。此外，嵌入式數位浮水印可與數位作品的副本一起複製，在實際應用中更加方便有效。但是數位浮水印技術在訊息的儲存和認證、強韌性和儲存空間以及其他方面仍有改進的空間。&lt;/p&gt;

&lt;p&gt;除虛擬貨幣外，近年來，區塊鏈技術已開始在其他領域擴展，包括數位版權保護。[4] [5] [6]。為了保護傳統的版權，版權所有者需要向註冊機構提供數位作品和一些個人訊息作為版權訊息。中心化機構將手動檢查提交的訊息並將其存儲在中心化伺服器中。這不僅導致效率低下和成本增加，而且還存在訊息被篡改和洩漏的風險。同時，這也給版權驗證者進行數位取證帶來了很多麻煩，因為有必要證明該訊息確實是原始訊息且不得更改。對於此方案，將使用區塊鏈儲存版權信息，並將訊息寫入區塊鏈後，將很難更改它。這將極大化促進版權驗證者的數位取證。在實際應用中，區塊鏈還可以幫助確認多個浮水印（多個版權），因為每個區塊都包含不可更改的時間戳記。如果獲得了所有浮水印訊息，即可在區塊鏈中搜索相應的區塊並檢查時間戳記。可以知道多個浮水印的嵌入順序，換句話說，可以知道數位圖像的創建順序。&lt;/p&gt;

&lt;p&gt;將圖像直接存儲在區塊鏈中是不切實際的。一種更實用、更方便的方法是對圖像進行雜湊處理，在區塊鏈中記錄這些圖像的雜湊值，然後將圖像文件儲存在其他位置以供調用。然而，對於圖像、文件之類的多媒體文件，使用 MD5 和 SHA256 之類的傳統密碼雜湊演算法並不是很合適 [7]。&lt;/p&gt;

&lt;p&gt;因為除了篡改內容外，圖像還將經歷正常的操作，例如添加數位浮水印、過濾、旋轉、壓縮等。這些操作不會引起圖像內容的變化，因此不會引起人體感覺系統產生感覺差異，當然這些圖像仍然被人類視為同一圖像。&lt;/p&gt;

&lt;p&gt;但是，此圖像的數據結構已被電腦更改，因此傳統雜湊函數的計算結果將完全不同。顯然，這不是我們想要看到的結果，因此它需要一種對內容操作具有強韌性並且對內容篡改敏感的新雜湊算法。&lt;/p&gt;

&lt;p&gt;感知雜湊函數在計算雜湊值之前對圖像執行一系列處理，例如減小大小和簡化顏色，刪除圖像的細節以及保留這些圖像的結構信息[7]。&lt;/p&gt;

&lt;p&gt;只要某個圖像的結構沒有改變，雜湊就不會改變 [8] [9]。
換句話說，在將數位浮水印添加到原始圖像後，結構信息將不會更改通過相同的感知雜湊函數計算浮水印圖像，並將計算出的雜湊值與提取的數位浮水印訊息進行比較。換句話說，在將數位浮水印添加到原始圖像後，通過相同的感知哈希函數計算水印圖像後，結構信息將不會更改。換句話說，在將數位浮水印添加到原始圖像，通過相同的感知雜湊函數計算浮水印圖像並將計算出的雜湊值與提取的數位浮水印信息進行比較之後，結構信息將不會改變。這樣，可以在沒有原始圖像的情況下對帶有浮水印的數位圖像進行自我認證[10] [11]。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-1.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖1 方案示意圖&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://ieeexplore-ieee-org.autorpa.lib.nkust.edu.tw/mediastore_new/IEEE/content/media/8376143/8377808/8377886/8377886-fig-1-source-small.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就用於版權保護的數位浮水印技術而言，對其強韌性的要求實際上非常高 [1][2][3]。不僅要求在一系列操作或攻擊之後可以檢測並提取數位浮水印，而且還要求提取的數位浮水印應清晰可辨，以確認版權信息。另外，浮水印空間也是一個重要特徵，因為它必須具有足夠的版權信息才能發揮版權保護的作用。對於這兩點，QR Code 圖像可用作數位浮水印圖像[12][13][14][15]。&lt;/p&gt;

&lt;p&gt;首先，QR Code 具有一定的容錯能力。即使 QR Code 圖像上有污點，機器仍可以讀取。通常，QR Code 圖像的污損區域仍可以在 7％-30％ 的範圍內讀取[12] [13]。這可以有效地提高數位浮水印技術的強韌性。其次，QR Code 可儲存更多信息，這對於提高水印空間非常有幫助。最後，大多數電子設備，尤其是智能手機，都可以識別 QR Code 圖像，並且在實際應用中會很方便。&lt;/p&gt;

&lt;p&gt;與其他傳統網路平台一樣，它需要有一個儲存圖像的位置，供用戶瀏覽和下載。傳統的中心化儲存有很多缺點，例如，它需要大型伺服器儲存。這樣會增加營運成本，並且一旦伺服器斷電或物理損壞和其他嚴重問題，就會影響圖像用戶的使用並帶來很多不便。更嚴重的是，一旦伺服器受到駭客攻擊，它將洩漏或破壞大量重要訊息，從而導致嚴重且不可估量的損失。&lt;/p&gt;

&lt;p&gt;星際檔案系統是點對點分散式文件儲存系統，用於通信協議和內容傳遞之網路[16]。為了便於描述，後面將使用縮寫詞 IPFS 來表示該系統。與 HTTP 不同，IPFS 不再關心中央伺服器的位置，並且不考慮文件名和路徑。它僅注意文件中可能出現的內容。將任何文件放置在 IPFS 節點上之後，將根據該文件的內容計算加密雜湊。當要求 IPFS 提供文件之雜湊時，它使用分散式雜湊表來尋找此文件所在的節點，然後搜索此文件並進行驗證。因此，使用 IPFS 可以大大降低網路平台的運營成本，並提高圖像文件儲存的安全性。此外，IPFS 實現了 HTTP 閘道，圖像用戶可用通用瀏覽器瀏覽任何內容並下載它們。&lt;/p&gt;

&lt;p&gt;本文的其餘部分安排如下。第二章節介紹該方案基於數位浮水印的圖像版權保護系統的組成以及該方案的過程。第三章節介紹了該方案的仿真。最後，第四章節總結了論文。&lt;/p&gt;

&lt;h1 id=&quot;第二章節---基於數位浮水印技術之改進數位圖像版權保護系統&quot;&gt;第二章節 - 基於數位浮水印技術之改進數位圖像版權保護系統&lt;/h1&gt;

&lt;p&gt;圖1 為該方案的示意圖。 首先在 A 小節中詳細介紹該方案的具體組件。圖中標誌的序列號是該系統的實現順序，將會在 B 小節中描述該方案的過程。&lt;/p&gt;

&lt;h2 id=&quot;a-計畫的組成&quot;&gt;A. 計畫的組成&lt;/h2&gt;

&lt;p&gt;該方案的組成部分可以分為兩部分。數位浮水印系統的第一部分包括雜湊生成、區塊鏈儲存、數位浮水印之圖像生成和數位浮水印嵌入。第二部分是關於含有浮水印的圖像和版權訊息的儲存和傳播。首先介紹第一部分，如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;感知雜湊函數將用於計算圖像的雜湊值作為圖像的 ID 號。其目的是在嵌入數位浮水印前和嵌入數位浮水印後，此圖像的雜湊值將不會更改。為了確保沒有原始圖像仍然可以驗證浮水印訊息。由於感知雜湊函數的這一特性，為了確保原始圖像和浮水印圖像不會混淆，還需要使用傳統的密碼雜湊函數。利用加密雜湊函數的特性，即在添加浮水印之前和之後對數據進行修改的敏感性，對兩個圖像進行加密雜湊計算，以證明它們之間的順序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;區塊鏈技術用於儲存有關圖像的訊息，如圖 1 所示，圖像的感知雜湊值，圖像所有者的訊息等。由於區塊鏈本質上是一個去中心化的數據庫，因此它可以通過&lt;strong&gt;加密&lt;/strong&gt;來相互驗證彼此的身份並安全地儲存沒有受信任的第三方的數據。區塊鏈網路中的每個節點都可以備份完整的區塊鏈數據，並且節點之間不知道彼此的真實身份。這大大降低了節點之間發生&lt;strong&gt;合夥篡改&lt;/strong&gt;數據的風險。在實際應用中，面對多個浮水印（多個版權）的問題，可以使用區塊鏈的時間戳記功能來解決。如前所述，關於區塊鏈的安全性，透過時間戳記數據也是不可更改的。獲取浮水印訊息後，可以根據該訊息獲取對應的區塊，以獲得對應的時間訊息，以證明多個浮水印之序列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有必要訊息都記錄在區塊鏈上後，這是第一部分的最後階段，即數位浮水印的生成和嵌入。為了提高數位浮水印的強韌性和攜帶的信息量，使用 QR Code 生成浮水印圖像。此 QR code 圖像包含記錄在區塊鏈中的擁有者的數位簽章。 為了提高數位浮水印的強韌性，浮水印嵌入過程採用基於&lt;strong&gt;頻率域&lt;/strong&gt;的數位浮水印嵌入方法。這裡使用的空頻域變換方法是離散餘弦變換（DCT）。具體方法將在第三章節中介紹。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;數位浮水印系統的工作已經結束，並將包含擁有者的數位簽章訊息的數位浮水印嵌入到原始圖像中。接下來是圖像用戶部分。該方案的第二部分如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;為了解決集中式伺服器中可能出現的問題，IPFS 用於儲存和傳播帶浮水印的圖像。將一個文件夾上傳到 IPFS 網路，該文件夾包括一個帶浮水印的圖像，以及一個文本文件，其中包含有關其相應區塊的訊息，該文件包含該區塊的&lt;strong&gt;索引&lt;/strong&gt;、該圖像的&lt;strong&gt;標題&lt;/strong&gt;，擁有者的名稱和電子郵件地址等。可以通過常見的瀏覽器瀏覽圖像和相關訊息，然後下載它們。具體操作也將在第三節中演示。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;b-計畫流程&quot;&gt;B. 計畫流程&lt;/h2&gt;

&lt;p&gt;如 圖1 中的（1）-（5）所示，該方案的具體過程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上傳原始圖像，然後提交一些版權擁有者的訊息和其他中介資料，例如真實姓名、電子郵件地址、圖片標題。 然後使用感知雜湊函數計算該圖像的感知雜湊值。 並使用加密雜湊函數來計算此原始圖像的加密雜湊值作為數位簽章。&lt;/li&gt;
  &lt;li&gt;感知雜湊值，版權擁有者的訊息和其他中介資料作為版權擁有者的數位簽章。 結合加密雜湊值，它們被用作交易的附加訊息，以向區塊鏈網路發起交易請求，並將這些記錄在區塊鏈中。&lt;/li&gt;
  &lt;li&gt;生成包含版權擁有者的數位簽章的 QR Code 圖像。 即感知雜湊值，版權擁有者的訊息和其他中介資料。&lt;/li&gt;
  &lt;li&gt;將此 QR Code 圖像用作數位浮水印圖像，將其嵌入到原始圖像中，並生成已添加數位浮水印的圖像，並使用加密雜湊函數來計算該浮水印圖像的加密雜湊值，並將其記錄在區塊鏈中。&lt;/li&gt;
  &lt;li&gt;將此帶浮水印的圖像文件及其阻止訊息上傳到 IPFS 網路。通過 IPFS 網路瀏覽並下載帶浮水印的圖像及其版權信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;已經引入了 圖1 所示的過程。用戶在獲取圖像後還需要驗證圖像，如下所示：&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用相同的感知雜湊函數來計算此浮水印圖像，並提取浮水印。將計算出的雜湊值，數位浮水印中的雜湊值和區塊鏈中的雜湊值相互比較以確定版權。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，完整的過程結束了。前面提到的多個浮水印問題，即每個圖像修改器都要經過步驟（1）-（5），最終形成一個包含多個數位浮水印的數位圖像。 然後，在步驟（6）中，提取所有數位浮水印，並基於浮水印訊息檢索相應的區塊以獲得時間戳記訊息。 最後，證明了數位浮水印的嵌入順序和數位圖像的創建順序。&lt;/p&gt;

&lt;h1 id=&quot;第三章節---計畫實驗&quot;&gt;第三章節 - 計畫實驗&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;仿真圖像為lena.jpg，如圖2所示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-2.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖2 原始 lena.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;a-計算圖像之雜湊值&quot;&gt;A. 計算圖像之雜湊值&lt;/h2&gt;

&lt;p&gt;在感知雜湊函數中，基本上有四個類別，即平均雜湊（AHA），差異雜湊（DHA），感知哈希（PHA）和小波雜湊（WHA）[12]。 由於仿真中 DHA的結果最好且誤差最小，因此選擇 DHA 進行實驗。 如圖3所示，lena.jpg 的哈希值是 6e0egedaccc85a1c。為了證明嵌入數位浮水印後圖像的變化，請使用 MD5 計算 lena.jpg，如圖4所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-3.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖3 lena.jpg 之雜湊值&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-4.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖4 使用 MD5 計算 lena.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;b-區塊鏈的產生&quot;&gt;B. 區塊鏈的產生&lt;/h2&gt;

&lt;p&gt;為了便於演示，透過 GitHub [17] [18] [19] [20] 上的區塊鏈程式，撰寫一個區塊鏈程式來模擬滿足此方案要求的區塊鏈功能。 然後使用網站 https://www.getpostman.com/ 提供的 Postman 進行接口請求測試並讀取區塊鏈中的數據。如 圖5 所示，啟動了區塊鏈網路中的一個節點。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-5.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖5 在區塊鏈網路中跑節點&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;如圖6所示，lena.jpg 的雜湊值和版權擁有者訊息作為附加訊息添加到交易中，然後將交易之應用程序啟動到區塊鏈網路。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-6.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖6 增加交易資訊至區塊中&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;區塊鏈網路中的節點將透過挖礦生成一個新區塊，如圖7所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-7.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖7 挖礦和生成區塊&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;經過其他節點確認後，新生成的區塊將添加到合法的區塊鏈中，如圖8所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-8.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖8 合法的區塊鏈&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;c-生成-qr-code-圖像&quot;&gt;C. 生成 QR Code 圖像&lt;/h2&gt;

&lt;p&gt;由於仿真圖像的尺寸為512 * 512，因此必須在可以讀取 QR Code 訊息的前提下限制 QR Code 圖像的尺寸。 所有參數盡量選擇最小的一個。 如 圖9 所示，使用該圖像的雜湊值和版權擁有者的訊息生成一個64 * 64  QR Code 圖像。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-9.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖9 QR Code 圖像 mark.png&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;d-嵌入和萃取數位浮水印&quot;&gt;D. 嵌入和萃取數位浮水印&lt;/h2&gt;

&lt;p&gt;使用 MATLAB 編寫基於離散餘弦變換（DCT）的頻率域數位浮水印算法進行仿真，並使用其逆變換（IDCT）提取浮水印[21] [22] [23]。這裡使用二維 DCT 和二維 IDCT。 F（μ，v）和 f（x，y）分別是 DCT 和IDCT 的&lt;strong&gt;變換係數&lt;/strong&gt;。c（μ）和 c（v）是&lt;strong&gt;相加係數&lt;/strong&gt;，其主要作用是使 DCT 和 IDCT 變換矩陣成為正交矩陣。如公式（1）、（2）和（3）所示。&lt;/p&gt;

&lt;p&gt;如圖10 和 11 所示，它們分別是浮水印圖像 lena_marked.jpg 和萃取的數位浮水印 markout.png。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-10.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖10 浮水印圖像 lena_marked.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-11.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖11 萃取數位浮水印 markout.png&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;和以前一樣，使用 MD5 計算帶浮水印的圖像 lena_marker.jpg。儘管兩個圖像看起來相同，但 MD5 值已更改，如圖12 所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-12.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖12 lena_marked.jpg 之 MD5 值&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;e-上傳和儲存圖像檔案及版權資訊&quot;&gt;E. 上傳和儲存圖像檔案及版權資訊&lt;/h2&gt;

&lt;p&gt;使用 IPFS 網站提供的 go-ipfs 軟件進行仿真。如圖13 所示，此電腦已作為 IPFS 網路中的節點成功啟動。圖3 顯示了該電腦在 IPFS 網路中的 ID 和本地 HTTP 地址&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-13.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖13 啟動 go-ipfs&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;創建一個名為 lena 的資料夾，其中包含兩個文件，這兩個文件是帶有浮水印的圖像 lena_marked.jpg 和包含版權訊息和相應區塊訊息的文本文件 copyright_information.txt。如圖14 所示，此文件夾已成功上傳到 IPFS，並且獲得了唯一證書-該文件夾的哈希值。此哈希值是IPFS 網路中此資料夾的名稱。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-14.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖14 上傳資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;f-瀏覽和下載圖像和版權訊息&quot;&gt;F. 瀏覽和下載圖像和版權訊息&lt;/h2&gt;

&lt;p&gt;與步驟E一樣，仍使用 go-ipfs 套件。成功上傳後，使用通用的 HTTP 瀏覽器瀏覽該文件夾。如圖15所示，在地址欄中輸入
http://localhost:8080/ipfs/QmXik2CN6GsSvxudKxoXdXGLpuAaKiuzkrLDuAg2chc8T2&lt;/p&gt;

&lt;p&gt;它成功顯示了該資料夾的內容。單擊任何文件以瀏覽內容，如圖16和17所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-15.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖15 顯示 lena 資料夾&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-16.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖16 顯示浮水印圖像 lena_marked.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-17.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖17 顯示浮水印內容 copyright_information.txt&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;接下來是下載 lena 資料夾。如圖18所示，成功下載此資料夾。下載的資料夾包含兩個文件 lena_marked.jpg 和 copyright_information.txt。 如圖19所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-18.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖18 下載資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-19.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖19 下載資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;g-自我驗證&quot;&gt;G. 自我驗證&lt;/h2&gt;

&lt;p&gt;DHA 仍用於計算原始圖像 lena.jpg 和帶水印的 lena_marked.jpg的雜湊值。最後，漢明碼距離用於比較這兩個雜湊值。如圖20所示，結果表明漢明碼距離為 0，因此這兩個圖像是同一圖像，並且兩個雜湊值均為6e0egedaccc85a1c。 該雜湊值與數位浮水印中的雜湊值和區塊鏈中的雜湊值一致，版權證明已完成。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-20.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖20 兩個雜湊值和漢明碼距離&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;第四章節---結論&quot;&gt;第四章節 - 結論&lt;/h1&gt;

&lt;p&gt;面對日益嚴重的數位版權保護問題，用於版權保護的技術也應得到增強。 在此方案中，使用數位浮水印、區塊鏈、感知雜湊功能，QR Code 和 IPFS 為快速發展的網路時代及數位版權保護作業提供了全新的選擇。在文件類型方面，本文僅提及數位圖像的版權管理。將來，它可以擴展到音頻、視頻和其他多媒體文件類型，以形成多種類型的版權管理系統。而且，本文提到的這些技術仍處於快速發展時期。相信將來，理論方面將更加完善、算法將更加成熟，可以為數位版權保護作業提供更強大的支持。&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Nicholas Paul Sheppard, Reihaneh Safavi-Naini, Philip Ogunbona, “Digital watermarks for copyright protection”, Journal of Law and Information Science, vol. 12, no. 1, pp. 110-130, 2002.&lt;/li&gt;
  &lt;li&gt;Deepa Merin Jose, R. Karuppathal, A. Vincent Antony Kumar, “Copyright Protection using Digital Watermarking”, National Conference on Advances in Computer Science and Applications with International Journal of Computer Applications (NCACSA) International Journal of Computer Applications (IJCA), 2012.&lt;/li&gt;
  &lt;li&gt;Chaw-Seng Woo, Digital Image Watermarking Methods for Copyright Protection and Authentication, March 2007.&lt;/li&gt;
  &lt;li&gt;Alexander Savelyev, “COPYRIGHT IN THE BLOCKCHAIN ERA: PROMISES AND CHALLENGES” in Basic Research Program Working Paper, National Research University Higher School of Economics (HSE), 2017.&lt;/li&gt;
  &lt;li&gt;Shigeru Fujimura, Hiroki Watanabe, Atsushi Nakadaira, Tomokazu Yamada, Akihito Akutsu, Jay-(Junichi) Kishigami, “BRIGHY: A Concept for a Decentralized Rights Management System Based on Blockchain”, IEEE 5 th International Conference on Consumer Electronics Berlin (ICCE-Berlin) , 2015.&lt;/li&gt;
  &lt;li&gt;Ruzhi Xu, Lu Zhang, Huawei Zhao, Yun Peng, “Design of Network Media’s Digital Rights Management Scheme Based on Blockchain Technology”, IEEE 13th International Symposium on Autonomous Decentralized Systems, 2017.&lt;/li&gt;
  &lt;li&gt;Christoph Zauner, Implementation and Benchmarking of Perceptual Image Hash Functions, July 2010.&lt;/li&gt;
  &lt;li&gt;Vladimir Viies, POSSIBLE APPLICATION OF PERCEPTUAL IMAGE HASHING, 2015.&lt;/li&gt;
  &lt;li&gt;Ruchita Kesarkar, RW Deshpande, “A Survey on Perceptual image hash for authentication of content”, International Research Journal of Engineering and Technology (IRJET), vol. 03, no. 01, January 2016.&lt;/li&gt;
  &lt;li&gt;Hirotsugu Kinoshita, Masafumi Satoh, Terunobu Kobayashi, “A WATERMARK SYSTEM BASED ON THE STRUCTURED INFORMATION”, European Association for Signal Processing 98, vol. 4, pp. 2273-2276, September 1998.&lt;/li&gt;
  &lt;li&gt;Hirotsugu Kinoshita, “AN IMAGE DIGITAL SIGNATURE SYSTEM WITH ZKIP FOR THE GRAPH ISOMORPHISM”, IEEE INTERNATIONAL CONFERENCE ON IMAGE PROCESSING ICIP96, vol. III, pp. 247-250, September 1996.&lt;/li&gt;
  &lt;li&gt;Peter Kieseberg, Manuel Leithner, Martin Mulazzani, Lindsay Munroe, Schrittwieser Sebastian, Mayank Sinha, Edgar Weippl, “QR Code Security”, the 8th International Conference on Advances in Mobile Computing and Multimedia, pp. 430-435, 8–10 November 2010.&lt;/li&gt;
  &lt;li&gt;Kevin Peng, Harry Sanabria, Derek Wu, Charlotte Zhu, “Security Overview of QR Codes”, Massachusetts Institute of Technology 6.857 Computer and Network Security, 2014.&lt;/li&gt;
  &lt;li&gt;Sumedha Nishane, V.M. Umale, “Digital Image Watermarking based on DWT using QR Code”, International Journal of Current Engineering and Technology, June 2015.&lt;/li&gt;
  &lt;li&gt;Yang-Wai Chow, Willy Susilo, Joseph Tonien, Wei Zong, “A QR Code Watermarking Approach based on the DWT-DCT Technique”, 22nd Australasian Conference on Information Security and Privacy, 2017.&lt;/li&gt;
  &lt;li&gt;Juan Benet, IPFS - Content Addressed Versioned P2P File System (DRAFT 3) (online), 2014, [online] Available: https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf.&lt;/li&gt;
  &lt;li&gt;pysimplechain, [online] Available: https://github.com/EricAlcaide/pysimplechain.&lt;/li&gt;
  &lt;li&gt;hands-on-learning, [online] Available: https://github.com/liuchengxu/hands-on-learning.&lt;/li&gt;
  &lt;li&gt;blockchain, [online] Available: https://github.com/itauber/blockchain.&lt;/li&gt;
  &lt;li&gt;blockchain, [online] Available: https://github.com/dvf/blockchain.&lt;/li&gt;
  &lt;li&gt;Adrian G. Bors, Ioannis Pitas, “IMAGE WATERMARKING USING DCT DOMAIN CONSTRAINTS”, Proceedings of 3rd IEEE International Conference on Image Processing, 19–19 September 1996.&lt;/li&gt;
  &lt;li&gt;Faisal Alurki, Russell Mersereau, “A ROBUST DIGITAL WATERMARK PROCEDURE FOR STILL IMAGES USING DCT PHASE MODULATION”, 10th European Signal Processing Conference, 4–8 September 2000.&lt;/li&gt;
  &lt;li&gt;Chetna, “Digital Image Watermarking using DCT”, A Monthly Journal of Computer Science and Information Technology, vol. 3, no. 9, pp. 586-591, September 2014.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">本篇文章翻譯自 Design Scheme of Copyright Management System Based on Digital Watermarking and Blockchain 的內容，數位浮水印概念我們從圖像、影像..等，已經玩了許久當他結合區塊鏈又會產生什麼火花呢？</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/panda-21.jpg" /></entry><entry><title type="html">比特幣粉塵和空塊</title><link href="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A/" rel="alternate" type="text/html" title="比特幣粉塵和空塊" /><published>2019-11-11T00:00:00+08:00</published><updated>2019-11-11T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A</id><content type="html" xml:base="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/比特币粉尘和空块.html&quot;&gt;原文&lt;/a&gt;：比特币粉尘和空块   &lt;br /&gt;
最近看了bitcoinj的TransactionOutput類發現了裡面的關於粉塵的一些功能。網上搜索關於比特幣粉塵的知識，發現了空塊攻擊和粉塵攻擊的一些說明，但是隻是簡單地進行表述而已。也看到了礦工如何利用各種手段進行作弊，這個可能就是區塊鏈所不能監控的了。所以我覺得區塊鏈的問題還是很多的。&lt;/p&gt;

&lt;h2 id=&quot;什麼是空塊攻擊&quot;&gt;什麼是空塊攻擊&lt;/h2&gt;

&lt;p&gt;空塊的意思很明確，就是區塊中沒有交易，其實不管怎麼樣應該是有一筆交易的，就是挖礦獎勵的coinbase交易。但是呢塊被接收是經過大量的計算工作量的，所以這個看起來有點不太現實。從經濟的角度來說這是不太靠譜，但是這種攻擊最大的好處就是不用啟動算力攻擊。比如說你有全網1%的算力，那麼發起空包攻擊的概率也是很大的，但是就是這1%的算力也是不小的投入。算力攻擊其實就是能控制全網51%的算力，這個時候你可以隨意更改區塊的資訊。我在想以後會不會出現網路攻擊，癱瘓大部分網路，在一小片網路中佔據算力，從本質上說，區域網內的機器也可以進行挖礦，所以也比較困難。&lt;/p&gt;

&lt;p&gt;另外個別情況下偶爾一次，也沒有問題，但短期內頻繁空塊就是攻擊了，其效果是使交易記憶體池變大，交易平均確認時間變長。其實已經有很多礦池消滅了空塊的，技術上沒有難度的。打包空塊並不會比打包滿塊有優勢。但是有ASICBoost專利就不同了，空塊有利於ASICBoost專利的實施。&lt;/p&gt;

&lt;h2 id=&quot;粉塵攻擊&quot;&gt;粉塵攻擊&lt;/h2&gt;

&lt;p&gt;如果要想理解粉塵攻擊就必須先理解什麼是粉塵。任何會消耗其費用三分之一以上的交易輸出都不是比特幣系統現在想要處理的東西，所以我們稱之為“粉塵輸出”，並且它們是非標準的。&lt;/p&gt;

&lt;p&gt;一個典型的輸出是33位元組（pubkey hash +操作碼），需要輸入148位元組的消耗，所以我們將它們加在一起以找出用於傳輸這個數值的總資料量。請注意，這個公式對於任何不是付費地址輸出的東西都是錯誤的，不幸的是，我們必須遵循比特幣核心的錯誤以確保我們被認為是標準。一個更好的公式可以估計滿足所有不同指令碼類型所需的資料大小，或者只是使用硬編碼33。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 這個是根據實時的資料進行的計算。
public Coin getMinNonDustValue(Coin feePerKb) {
    final long size = this.unsafeBitcoinSerialize().length + 148;
    // 計算交易費
    return feePerKb.multiply(size).divide(1000);
}
// 預設是費用的3倍
public Coin getMinNonDustValue() {
    return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的這段程式碼就是用來計算最小的輸出，如果小於這個輸出值，我們就認為這個輸出是粉塵輸出。&lt;/p&gt;

&lt;h2 id=&quot;關於小金額的問題&quot;&gt;關於小金額的問題&lt;/h2&gt;

&lt;p&gt;如果地址上未花費輸出比較小，那麼很有可能就是使用的時候，這筆錢都不能支付交易費（這就是粉塵判斷所不能接受的），這樣會損失金額。也可以通過賬戶不停地將賬戶的錢轉移到大賬戶裡面去，看來不管是何種數字貨幣，都不能避免零頭損失的問題。我們做錢包的應用多少都存在這樣的問題。但是以太坊不是基於UTXO，而是基於賬戶多少能緩解不少的問題。&lt;/p&gt;

&lt;h2 id=&quot;廣播攻擊&quot;&gt;廣播攻擊&lt;/h2&gt;

&lt;p&gt;如果不停地向網路廣播大量的垃圾交易會阻塞網路，如果我們的節點能檢測出這個交易是非法的，並且停止廣播，那麼這個問題就不會很嚴重，但是如果修改了程式碼，不做這個的檢測就會出現大問題。比如說礦池大量傳送這樣的交易，這就會引起災難性的後果。&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：比特币粉尘和空块 最近看了bitcoinj的TransactionOutput類發現了裡面的關於粉塵的一些功能。網上搜索關於比特幣粉塵的知識，發現了空塊攻擊和粉塵攻擊的一些說明，但是隻是簡單地進行表述而已。也看到了礦工如何利用各種手段進行作弊，這個可能就是區塊鏈所不能監控的了。所以我覺得區塊鏈的問題還是很多的。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/134.jpg" /></entry><entry><title type="html">比特幣地址和 script</title><link href="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&script/" rel="alternate" type="text/html" title="比特幣地址和 script" /><published>2019-11-11T00:00:00+08:00</published><updated>2019-11-11T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&amp;script</id><content type="html" xml:base="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&amp;script/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/比特币地址和脚本.html&quot;&gt;原文&lt;/a&gt;：比特币地址和脚本  &lt;br /&gt;
這兩天由於要做多簽名的錢包的問題，所以一直在關注比特幣錢包的知識，當我看到bitcoinj裡面的知識時，發現了ScriptBuilder的類，也發現了bitcoinj文件中有提到怎麼使用多簽名的錢包，這裡就簡單帶過吧，今天的主題還是要說明錢包的地址和 script 的一些知識。&lt;/p&gt;

&lt;h2 id=&quot;地址&quot;&gt;地址&lt;/h2&gt;

&lt;p&gt;首先關於錢包地址大概有以下幾種：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;類型&lt;/th&gt;
      &lt;th&gt;版本字首（hex）&lt;/th&gt;
      &lt;th&gt;Base58結果的字首&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;傳統bitcoin地址&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P2SH&lt;/td&gt;
      &lt;td&gt;0x05&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比特幣測試網路地址&lt;/td&gt;
      &lt;td&gt;0x6F&lt;/td&gt;
      &lt;td&gt;m或者n&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;私鑰WIF&lt;/td&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;5、K、L&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIP-38編碼私鑰&lt;/td&gt;
      &lt;td&gt;0x0142&lt;/td&gt;
      &lt;td&gt;6P&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIP-32編碼私鑰&lt;/td&gt;
      &lt;td&gt;0x0488B21E&lt;/td&gt;
      &lt;td&gt;xpub&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其實地址的類型和交易的解鎖也是有很大的相關關係的。 &lt;strong&gt;如果你創造了一種新的地址類型，並配置了相關的鎖定和解鎖 script ，那麼這個地址是可以工作的，只是沒有錢包支援，你需要提供能夠利用這種地址類型，傳送解鎖和鎖定 script 的客戶端，這樣你的地址就可以生效了，當然你也要相容其他類型，如果傳送的地址類型是其他的，那你的輸出 script 要按照對應地址類型的要求來才行&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;比特幣地址的生成規則如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/132.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;傳統的比特幣地址-script-p2pkh&quot;&gt;傳統的比特幣地址 script P2PKH&lt;/h2&gt;

&lt;p&gt;對於比特幣 script 的語言介紹這裡不提太多，比特幣 script 其實就是一種基於堆棧的 script 語言，堆棧是一個非常簡單的資料結構，可以被視為一疊卡片。棧允許兩個操作：push和pop（推送和彈出）。&lt;/p&gt;

&lt;p&gt;對於解鎖 script 大概是這樣的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 OP_DUP OP_HASH160 &amp;lt;Cafe Public Key Hash&amp;gt; OP_EQUALVERIFY OP_CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;前面輸出的鎖定 script 是這樣的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sig&amp;gt; &amp;lt;pubk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那麼整體的 script 是這樣的：
&lt;img src=&quot;/img/133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;p2sh&quot;&gt;P2SH&lt;/h2&gt;

&lt;p&gt;Gavin Andresen在bip16提出一種P2SH(pay to Script Hash)方法，主要目的有兩個，一是容許傳送者構造豐富的交易類型，二是將位元組從A-&amp;gt;B的output轉移到B-&amp;gt;C的input(A-&amp;gt;B的output script中將是固定長度)。&lt;/p&gt;

&lt;p&gt;對於解鎖的 script 是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我們可以理解成解數學中的難題，hash(x) = 6fe28c0ab6f1b372c1a6 我們只是提供一個x滿足這個條件，就可以證明我可以花費這筆錢了。這裡 &lt;code class=&quot;highlighter-rouge&quot;&gt;6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000&lt;/code&gt; 不是簡單的一個數字的hash，而是一段script的hash(簡稱redeemScript),  &lt;strong&gt;我們可以理解成只要你提供了一段script，它的二進位制hash和目標匹配，那麼你就可以花費這筆錢了，注意這裡是前端 script 執行的輸出是x就行了。&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;請注意，雖然這樣的交易很有趣，但它們並不安全，因為它們不包含任何簽名，因此任何試圖花費它們的交易都可以用將資金髮送到其他地方，用不同的交易來替代&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;p2sh地址生成&quot;&gt;P2SH地址生成&lt;/h3&gt;

&lt;p&gt;可以使用 go-bitcoin-multisig 生成，Github地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go-bitcoin-multisig keys --count 3 --concise
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成結果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #1
Private key:
5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3
Public key hex:
04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd
Public Bitcoin address:
1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #2
Private key:
5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk
Public key hex:
046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187
Public Bitcoin address:
14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #3
Private key:
5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV
Public key hex:
0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
Public Bitcoin address:
1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著我們取出裡面所有的Public key（hex格式）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Key A:
04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd
Key B:
046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187
Key C:
0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然後就可以使用這三組Public key組合起來（A,B,C）進行多重簽名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著就生成了P2SH地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;Your *P2SH ADDRESS* is:
347N1Thc213QqfYCz3PZkjoJpNv5b14kBd
Give this to sender funding multisig address with Bitcoin.
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
---------------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;Your *REDEEM SCRIPT* is:
524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae
Keep private and provide this to redeem multisig balance later.
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;多重簽名地址&quot;&gt;多重簽名地址&lt;/h2&gt;

&lt;p&gt;在bitcoin bips歷史上先有M-of-N Transaction(bip-11),然後才有Pay To Script Hash(bip-16)(簡稱P2SH). 按照這個順序，其實比特幣中實現多重簽名有兩種方法：&lt;/p&gt;

&lt;h3 id=&quot;原始的方法bip-11&quot;&gt;原始的方法(bip-11)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scriptPubKey : m {pubkey}...{pubkey} n OP_CHECKMULTISIG
scriptSig : OP_0 ...signatures...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以檢視一下例項：&lt;code class=&quot;highlighter-rouge&quot;&gt;09dd94f2c85262173da87a745a459007bb1eed6eeb6bfa238a0cd91a16cf7790&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;用p2sh來實現&quot;&gt;用P2SH來實現&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scriptSig: [signature] {[pubkey] OP_CHECKSIG}
scriptPubKey: OP_HASH160 [20-byte-hash of {[pubkey] OP_CHECKSIG} ] OP_EQUAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這裡&lt;code class=&quot;highlighter-rouge&quot;&gt;{[pubkey] OP_CHECKSIG}&lt;/code&gt;就是我們提到&lt;code class=&quot;highlighter-rouge&quot;&gt;redeemScript&lt;/code&gt;程式碼. 例項：&lt;code class=&quot;highlighter-rouge&quot;&gt;3c9018e8d5615c306d72397f8f5eef44308c98fb576a88e030c25456b4f3a7ac&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;總結&quot;&gt;總結&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;首先P2SH和MultiSig是完全不同兩碼事，很多文章將P2SH表述成MultiSig，這是不恰當的。只不過現在可以用P2SH來實現MultiSig。&lt;/li&gt;
  &lt;li&gt;比特幣的關鍵是認證，剛開始中本聰提供用私鑰認證，後來人發明了用hash(redeemScript)認證.&lt;/li&gt;
  &lt;li&gt;P2SH豐富了交易類型，簡單易擴充套件&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;參考和引用&quot;&gt;參考和引用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://8btc.com/thread-23440-1-1.html&quot;&gt;http://8btc.com/thread-23440-1-1.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：比特币地址和脚本 這兩天由於要做多簽名的錢包的問題，所以一直在關注比特幣錢包的知識，當我看到bitcoinj裡面的知識時，發現了ScriptBuilder的類，也發現了bitcoinj文件中有提到怎麼使用多簽名的錢包，這裡就簡單帶過吧，今天的主題還是要說明錢包的地址和 script 的一些知識。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/131.png" /></entry><entry><title type="html">BIP 173 Bech32 address</title><link href="http://localhost:4000/news/2019/11/10/BIP-173-Bech32%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/" rel="alternate" type="text/html" title="BIP 173 Bech32 address" /><published>2019-11-10T00:00:00+08:00</published><updated>2019-11-10T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/10/BIP:%20173%20-%20Bech32%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/news/2019/11/10/BIP-173-Bech32%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/">&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BIP: 173 Layer: Applications 
Title: Base32 address format for native v0-16 witness outputs 
Author: Pieter Wuille &amp;lt;pieter.wuille@gmail.com&amp;gt; Greg Maxwell &amp;lt;greg@xiph.org&amp;gt; 
Comments-Summary: No comments yet. 
Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0173 
Status: Final 
Type: Informational 
Created: 2017-03-20 
License: BSD-2-Clause 
Replaces: 142
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;介紹--introduction&quot;&gt;介紹 ｜ Introduction&lt;/h2&gt;

&lt;h3 id=&quot;摘要--abstract&quot;&gt;摘要 ｜ Abstract&lt;/h3&gt;

&lt;p&gt;本文件提出了checksum和的base32格式” Bech32”，以及使用該格式的native segregated witness output地址的標準。&lt;/p&gt;

&lt;h3 id=&quot;版權--copyright&quot;&gt;版權 ｜ Copyright&lt;/h3&gt;

&lt;p&gt;This BIP is licensed under the 2-clause BSD license.&lt;/p&gt;

&lt;h3 id=&quot;動機--motivation&quot;&gt;動機 ｜ Motivation&lt;/h3&gt;

&lt;p&gt;在其歷史的大部分時間裡，比特幣都依賴於帶有切去頭部的double-SHA256 checksum和的base58地址。 它們是原始軟體的一部分，其範圍已在&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki&quot;&gt;BIP13&lt;/a&gt;擴展為Pay-to-script-hash (&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;P2SH&lt;/a&gt;)。 但是，字符集(character set)和checksum演算法都有局限性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Base58在QR codes中需要大量空間，因為它不能使用字母數字模式。&lt;/li&gt;
  &lt;li&gt;base58中的混合大小寫不方便可靠地寫下，在手機鍵盤上輸入或電腦朗讀聲音。&lt;/li&gt;
  &lt;li&gt;double SHA256 checksum很慢，並且沒有錯誤檢測保證。&lt;/li&gt;
  &lt;li&gt;關於錯誤檢測(error-detecting)程式碼的大多數研究僅適用於作為&lt;a href=&quot;https://en.wikipedia.org/wiki/Prime_power&quot;&gt;prime power&lt;/a&gt;的character set大小，不適用於58。&lt;/li&gt;
  &lt;li&gt;Base58解碼複雜且相對較慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Segregated Witness proposal中包括一類新的輸出（見證程序，witness programs，請參見&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki&quot;&gt;BIP141&lt;/a&gt;)），以及兩個輸出實例（” P2WPKH”和” P2WSH”，請參見&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki&quot;&gt;BIP143&lt;/a&gt;）。 通過嵌入P2SH輸出，它們的功能可以間接提供給較老的客戶端，但是為了獲得最佳的效率和安全性，最好直接使用它。 在本文件中，我們為native witness outputs （當前和將來的版本）提出了一種新的地址格式。&lt;/p&gt;

&lt;p&gt;它替代了&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0142.mediawiki&quot;&gt;BIP142&lt;/a&gt;，並在前面進行了討論（在&lt;a href=&quot;https://bitcoincore.org/en/meetings/2016/05/20/#error-correcting-codes-for-future-address-types&quot;&gt;這裡&lt;/a&gt;進行了概述）。&lt;/p&gt;

&lt;h3 id=&quot;例子--examples&quot;&gt;例子 ｜ Examples&lt;/h3&gt;

&lt;p&gt;所有的例子使用 public key &lt;code class=&quot;highlighter-rouge&quot;&gt;0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798&lt;/code&gt;. P2WSH 的例子使用 key OP_CHECKSIG as script.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mainnet P2WPKH: &lt;code class=&quot;highlighter-rouge&quot;&gt;bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Testnet P2WPKH: &lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Mainnet P2WSH: &lt;code class=&quot;highlighter-rouge&quot;&gt;bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Testnet P2WSH: &lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;格式--specification&quot;&gt;格式 ｜ Specification&lt;/h2&gt;

&lt;p&gt;我們首先描述的一般checksummed base32 [&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-1&quot;&gt;1&lt;/a&gt;]的格式稱為Bech32，然後用它定義 Segregated Witness 地址。&lt;/p&gt;

&lt;h3 id=&quot;bech32&quot;&gt;Bech32&lt;/h3&gt;

&lt;p&gt;Bech32 [&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-2&quot;&gt;2&lt;/a&gt;]string的長度最多為90個characters，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;人類可讀的部分(human-readable part, HRP)&lt;/strong&gt;，旨在傳達數據的類型或與讀者相關的任何其他內容。 此部分必須包含1到83個US-ASCII characters，每個character的值都在[33-126]範圍內。 HRP有效性可能會受到特定應用程序的進一步限制。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分隔符(separator)&lt;/strong&gt;，始終為” 1”。 如果在人類可讀部分內部允許” 1”，則string中的最後一個是分隔符[&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-3&quot;&gt;3&lt;/a&gt;]。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;數據部分&lt;/strong&gt;至少長6個characters，並且僅由字母數字characters組成，但不包括” 1”，” b”，” i”和” o” [&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-4&quot;&gt;4&lt;/a&gt;]。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+0&lt;/td&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;z&lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+8&lt;/td&gt;
      &lt;td&gt;g&lt;/td&gt;
      &lt;td&gt;f&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;t&lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+16&lt;/td&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;n&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;h&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+24&lt;/td&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;e&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;u&lt;/td&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;l&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Checksum&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;數據部分的最後六個characters構成一個Checksum，不包含任何訊息。 有效strings必須通過下面的Python3程式碼段指定的有效性標準。 當參數為以下參數時，bech32_verify_checksum函數必須返回true：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hrp: string形式的人類可讀部分&lt;/li&gt;
  &lt;li&gt;data: 數據部分為整數列表，代表使用上表進行轉換後的characters&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def bech32_polymod(values):
  GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
  chk = 1
  for v in values:
    b = (chk &amp;gt;&amp;gt; 25)
    chk = (chk &amp;amp; 0x1ffffff) &amp;lt;&amp;lt; 5 + v
    for i in range(5):
      chk += GEN[i] if ((b &amp;gt;&amp;gt; i) &amp;amp; 1) else 0
  return chk

def bech32_hrp_expand(s):
  return [ord(x) &amp;gt;&amp;gt; 5 for x in s] + [0] + [ord(x) &amp;amp; 31 for x in s]

def bech32_verify_checksum(hrp, data):
  return bech32_polymod(bech32_hrp_expand(hrp) + data) == 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這實現了一個&lt;a href=&quot;https://en.wikipedia.org/wiki/BCH_code&quot;&gt;BCH code&lt;/a&gt;，該程式碼可確保檢測到最多影響4個characters的任何錯誤，並且在109個失敗的機會中無法檢測到更多的錯誤。 有關屬性的更多詳細信息，請參見”Checksum設計”附件。 可讀部分的處理方法是，首先將每個character的US-ASCII值的higher bits輸入checksum，然後是零，然後是lower bits[&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-5&quot;&gt;5&lt;/a&gt;]。&lt;/p&gt;

&lt;p&gt;要根據給定的可讀部分和數據部分characters的（非checksum）值構造有效的checksum，可以使用以下程式碼：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def bech32_create_checksum(hrp, data):
  values = bech32_hrp_expand(hrp) + data
  polymod = bech32_polymod(values + [0,0,0,0,0,0]) + 1
  return [(polymod &amp;gt;&amp;gt; 5 * (5 - i)) &amp;amp; 31 for i in range(6)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;錯誤修正 ｜ Error correction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;這些BCH程式碼的特性之一是它們可用於錯誤修正。 錯誤修正的一個不幸的副作用是它侵蝕了錯誤檢測：錯誤修正將無效輸入更改為有效輸入，但是如果進行了多個錯誤，則有效輸入可能不是正確輸入。 使用不正確但有效的輸入會導致資金無法挽回流失。 因此，實現方式不應該向用戶暗示在string中可能存在錯誤的位置，而不建議用戶進行更正，而不能進行更正。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大寫小寫 ｜ Uppercase/lowercase&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在確定用於checksum目的的character值時，使用小寫形式。&lt;/p&gt;

&lt;p&gt;編碼器務必始終輸出全小寫的Bech32 string。 如果需要編碼結果的大寫版本（例如-為了表示目的或使用QR code），則可以在編碼過程外部執行大寫過程。&lt;/p&gt;

&lt;p&gt;解碼器絕不能接受某些characters為大寫而某些characters為小寫的strings（此類strings稱為大小寫混合的strings）。&lt;/p&gt;

&lt;p&gt;為了便於演示，通常最好使用小寫字母，但在QR code內部應使用大寫字母，因為那些允許使用字母數字模式(&lt;a href=&quot;http://www.thonky.com/qr-code-tutorial/alphanumeric-mode-encoding&quot;&gt;alphanumeric mode&lt;/a&gt;)，比普通&lt;a href=&quot;http://www.thonky.com/qr-code-tutorial/byte-mode-encoding&quot;&gt;byte mode&lt;/a&gt;簡洁45％。&lt;/p&gt;

&lt;h3 id=&quot;segwit-address-format格式&quot;&gt;Segwit address format(格式)&lt;/h3&gt;

&lt;p&gt;A segwit 地址[&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-6&quot;&gt;6&lt;/a&gt;] 是以下內容的Bech32編碼：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;對於mainnet人類可讀部分”bc”[&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-7&quot;&gt;7&lt;/a&gt;]，以及用於testnet”tb”[&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_note-8&quot;&gt;8&lt;/a&gt;]。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;數據部分的值：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;1 byte: witness 版本&lt;/li&gt;
      &lt;li&gt;將2-to-40-byte的witness program（由&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki&quot;&gt;BIP141&lt;/a&gt;定義）轉換為base32：
        &lt;ul&gt;
          &lt;li&gt;從 witness program 的bit開始，首先是每個byte的最高有效bit。&lt;/li&gt;
          &lt;li&gt;將這些bit重新排列為5組，並在需要時在末尾加零。&lt;/li&gt;
          &lt;li&gt;使用上表將這些bit轉換為characters。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解碼 ｜ Decoding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;軟體解釋 segwit 地址:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MUST驗證人類可讀的部分是”bc”為mainnet和”tb”的用於testnet。&lt;/li&gt;
  &lt;li&gt;MUST驗證第一個解碼的數據值（witness version）在0到16之間（含0和16）。&lt;/li&gt;
  &lt;li&gt;將其餘數據轉換為bytes：
    &lt;ul&gt;
      &lt;li&gt;將值轉換為5bits，最高有效bit在前。&lt;/li&gt;
      &lt;li&gt;將這些bits重新排列為8bits的組。 最後任何不完整的組必須為4bits或更少，必須全為零，並被丟棄。&lt;/li&gt;
      &lt;li&gt;MUST在2到40個組之間，這被解釋為witness program的bytes。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解碼器應該對witness program施加已知長度的限制。 例如，BIP141指定如果version byte為0，但是witness  program既不是20bytes也不是32bytes，則script必須失效。&lt;/p&gt;

&lt;p&gt;根據先前的規則，地址的長度始終在14到74個characters之間，其modulo 8的長度不能為0、3或5。版本0的witness地址始終為42或62個characters，但是實現必須允許使用任何版本。&lt;/p&gt;

&lt;p&gt;將地址轉換為scriptPubkey時，實現時應格外小心，其中witness version &lt;em&gt;n&lt;/em&gt; 存儲為 &lt;em&gt;OP_n&lt;/em&gt; 。 OP_0編碼為0x00，但OP_1至OP_16編碼為0x51至0x60（十進制為81至96）。如果將bech32地址轉換為不正確的scriptPubKey，則結果可能是不可花費的或不安全的。&lt;/p&gt;

&lt;h3 id=&quot;兼容性--compatibility&quot;&gt;兼容性 ｜ Compatibility&lt;/h3&gt;

&lt;p&gt;只有新軟體才能使用這些地址，並且僅適用於具有啟用了segregated witness功能的新軟體的接收器。在所有其他情況下，可以使用P2SH或P2PKH地址。&lt;/p&gt;

&lt;h2 id=&quot;解釋--rationale&quot;&gt;解釋 ｜ Rationale&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-1-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼要全部使用base32？&lt;/strong&gt; 缺少混合大小寫，使朗讀或放入QR code 更加有效。的確增加了15％的長度，但這與復制貼上地址無關緊要。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-2-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼稱其為Bech32？&lt;/strong&gt;  “ Bech”包含characterBCH（使用的錯誤檢測演算法），聽起來有點像” base”。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-3-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼在地址中包含分隔符？&lt;/strong&gt; 這樣，人類可讀部分便與數據部分明確分離，避免了與其他共享前綴的人類可讀部分的潛在衝突。這也使我們避免了對人類可讀部分的character set限制。分隔符為1，因為使用非字母數字character會使地址的複制貼上變得複雜（在某些應用程序中沒有雙擊選擇）。因此，選擇了正常character set之外的字母數字character。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-4-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼不使用&lt;a href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;RFC3548&lt;/a&gt;或&lt;a href=&quot;https://philzimmermann.com/docs/human-oriented-base-32-encoding.txt&quot;&gt;z-base-32&lt;/a&gt;&lt;a href=&quot;https://hissa.nist.gov/~black/GTLD/&quot;&gt;this&lt;/a&gt;的現有character set？&lt;/strong&gt; 根據此視覺相似性數據選擇character set以最大程度地減少歧義，選擇順序以最小化相差超過1 bit的相似character對（根據同一數據）的數量。選擇Checksum以最大程度地減少少量誤碼的檢測能力，因此在某些錯誤模型下，此選擇可提高其性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-5-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼首先要處理人類可讀部分的higher bits？&lt;/strong&gt; 這導致實際Checksum的數據為[高] 0 [低] [數據]。這意味著在假設人類可讀部分的錯誤僅會更改低5 bit（例如將字母character更改為另一個character）的情況下，錯誤僅限於[low] [data]部分，該部分最多為89個character，並且因此，所有錯誤檢測屬性（請參閱附件）仍然適用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-6-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼不為所有scriptPubKeys創建通用的地址格式？&lt;/strong&gt; 這將導致現有scriptPubKey類型的地址混亂。此外，如果曾經引入沒有與scriptPubKeys一一對應的地址（例如基於ECDH的地址），則擁有完全通用的舊地址類型將允許使用舊地址格式重新解釋結果的scriptPubKeys，如果將比特幣發送給他們，則會導致資金損失。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-7-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼使用” bc”作為人類可讀的部分而不使用” btc”？&lt;/strong&gt;” bc”較短。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/5ecba9af777886120595f6eaece8e061e07611de/bip-0173.mediawiki#cite_ref-8-0&quot;&gt;+&lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;為什麼將’tb’用作testnet的人類可讀部分？&lt;/strong&gt; 它被選擇為與mainnet對應的長度相同（以簡化實現對長度的假設），但在視覺上仍然截然不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;參考實現--reference-implementations&quot;&gt;參考實現 ｜ Reference implementations&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;參考編碼器和解碼器:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/c&quot;&gt;For C&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/c++&quot;&gt;For C++&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/javascript&quot;&gt;For JavaScript&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/go&quot;&gt;For Go&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/python&quot;&gt;For Python&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/haskell&quot;&gt;For Haskell&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/ruby&quot;&gt;For Ruby&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ref/rust&quot;&gt;For Rust&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fancy decoder that localizes errors:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/sipa/bech32/tree/master/ecc/javascript&quot;&gt;For JavaScript&lt;/a&gt; (&lt;a href=&quot;http://bitcoin.sipa.be/bech32/demo/demo.html&quot;&gt;demo website&lt;/a&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;已註冊的人類可讀前綴--registered-human-readable-prefixes&quot;&gt;已註冊的人類可讀前綴 ｜ Registered Human-readable Prefixes&lt;/h2&gt;

&lt;p&gt;SatoshiLabs維護其他密碼貨幣的已註冊的人類可讀部件的完整列表：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/satoshilabs/slips/blob/master/slip-0173.md&quot;&gt;SLIP-0173 : Registered human-readable parts for BIP-0173&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;附件--appendices&quot;&gt;附件 ｜ Appendices&lt;/h2&gt;

&lt;h3 id=&quot;測試向量--test-vectors&quot;&gt;測試向量 ｜ Test vectors&lt;/h3&gt;

&lt;p&gt;以下strings是有效的 Bech32：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A12UEL5L&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a12uel5l&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?1ezyfcl&lt;/code&gt; 警告：在轉換為US-ASCII期間，某些編碼器可能會將不可映射的character設置為有效的US-ASCIIcharacter，例如”？”。例如：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bech32_encode('\x80'.encode('ascii', 'replace').decode('ascii'), [])
'?1ezyfcl'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下String不是有效的Bech32（具有無效原因）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0x20 + &lt;code class=&quot;highlighter-rouge&quot;&gt;1nwldj5&lt;/code&gt;: HRP character out of range&lt;/li&gt;
  &lt;li&gt;0x7F + &lt;code class=&quot;highlighter-rouge&quot;&gt;1axkwrx&lt;/code&gt;: HRP character out of range&lt;/li&gt;
  &lt;li&gt;0x80 + &lt;code class=&quot;highlighter-rouge&quot;&gt;1eym55h&lt;/code&gt;: HRP character out of range&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx&lt;/code&gt;: overall max length exceeded&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pzry9x0s0muk&lt;/code&gt;: No separator character&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1pzry9x0s0muk&lt;/code&gt;: Empty HRP&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x1b4n0q5v&lt;/code&gt;: Invalid data character&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;li1dgmt3&lt;/code&gt;: Too short checksum&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;de1lg7wt&lt;/code&gt; + 0xFF: Invalid character in checksum&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A1G7SGD8&lt;/code&gt;: checksum calculated with uppercase form of HRP&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10a06t8&lt;/code&gt;: empty HRP&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1qzzfhee&lt;/code&gt;: empty HRP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following list gives valid segwit addresses and the scriptPubKey that they translate to in hex.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4: 0014751e76e8199196d454941c45d1b3a323f1433bd6&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC1SW50QA3JX3S&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;6002751e&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;5210751e76e8199196d454941c45d1b3a323&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下列表提供了無效的segwit地址及其無效的原因。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty&lt;/code&gt;: Invalid human-readable part&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5&lt;/code&gt;: Invalid checksum&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2&lt;/code&gt;: Invalid witness version&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1rw5uspcuh&lt;/code&gt;: Invalid program length&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90&lt;/code&gt;: Invalid program length&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P&lt;/code&gt;: Invalid program length for witness version 0 (per BIP141)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7&lt;/code&gt;: Mixed case&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du&lt;/code&gt;: zero padding of more than 4 bits&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv&lt;/code&gt;: Non-zero padding in 8-to-5 conversion&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc1gmk9yu&lt;/code&gt;: Empty data section&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;checksum-設計&quot;&gt;Checksum 設計&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;設計選擇&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BCH程式碼可以構建在任何prime-power字母上，並且可以選擇在大小和錯誤檢測功能之間進行良好權衡。儘管大多數圍繞BCH程式碼的工作都使用二進製字母，但這不是必要的。這使它們比&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC codes&lt;/a&gt;更適合我們的用例。與&lt;a href=&quot;https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction&quot;&gt;Reed-Solomon codes&lt;/a&gt;不同，它們的長度不限於字母大小的一分之一。儘管它們還支持有效的錯誤糾正，但是僅錯誤檢測的實現非常簡單。&lt;/p&gt;

&lt;p&gt;我們選擇6個checksum characters作為地址長度和錯誤檢測功能之間的權衡，因為6個characters是足以保證隨機故障發生率低於十億分之一的最低數字。 對於我們希望保護的數據長度（對於將來可能的40bytes witness program而言，該字段的最大長度為71個bytes），可以構造BCH程式碼以確保檢測到最多4個錯誤。.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;選定的屬性 ｜ Selected properties&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;這些程式碼中的許多程式碼在處理更多錯誤時的性能不佳，但並非全部。因此，我們考慮旨在僅檢測3個錯誤和4個錯誤的程式碼，並分析它們在實踐中的性能。&lt;/p&gt;

&lt;p&gt;此處選擇的特定程式碼是以下結果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;從159605個BCH程式碼的詳盡列表開始，這些程式碼旨在檢測長度為93、151、165、341、1023和1057的3個或4個錯誤。&lt;/li&gt;
  &lt;li&gt;從這些錯誤中，需要檢測到長度為71的4個錯誤，導致剩餘28825個程式碼。&lt;/li&gt;
  &lt;li&gt;從這些程式碼中，選擇具有5個character錯誤的最壞情況窗口的程式碼，從而剩下310個程式碼。&lt;/li&gt;
  &lt;li&gt;從這些程式碼中，選擇機會最少的程式碼來檢測少量的 &lt;em&gt;bit&lt;/em&gt; 錯誤。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由於naive的搜索需要超過6.5 * 1019的Checksum評估，因此使用了衝突搜索(collision-search)方法進行分析。可以在&lt;a href=&quot;https://github.com/sipa/ezbase32/&quot;&gt;here&lt;/a&gt;找到程式碼。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;屬性 ｜ Properties&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下表總結了檢測失敗的可能性（109 中的 1 倍）&lt;/p&gt;

&lt;p&gt;Window length Number of wrong characters&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;長度&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;≤4&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;th&gt;≥9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Longest detecting 6 errors&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1.127&lt;/td&gt;
      &lt;td&gt;0.909&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;Longest detecting 5 errors&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0.965&lt;/td&gt;
      &lt;td&gt;0.929&lt;/td&gt;
      &lt;td&gt;0.932&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;Worst case for 6 errors&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.093&lt;/td&gt;
      &lt;td&gt;0.972&lt;/td&gt;
      &lt;td&gt;0.928&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;Length for a P2WPKH address&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.756&lt;/td&gt;
      &lt;td&gt;0.935&lt;/td&gt;
      &lt;td&gt;0.932&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;Length for a P2WSH address&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.805&lt;/td&gt;
      &lt;td&gt;0.933&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;Length for a 40-byte program address&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.830&lt;/td&gt;
      &lt;td&gt;0.934&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;89&lt;/td&gt;
      &lt;td&gt;Longest detecting 4 errors&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.867&lt;/td&gt;
      &lt;td&gt;0.933&lt;/td&gt;
      &lt;td&gt;0.931&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This means that when 5 changed characters occur randomly distributed in the 39 characters of a P2WPKH address, there is a chance of  &lt;em&gt;0.756 per billion&lt;/em&gt;  that it will go undetected. When those 5 changes occur randomly within a 19-character window, that chance goes down to  &lt;em&gt;0.093 per billion&lt;/em&gt; . As the number of errors goes up, the chance converges towards  &lt;em&gt;1 in 230&lt;/em&gt;  =  &lt;em&gt;0.931 per billion&lt;/em&gt; .&lt;/p&gt;

&lt;p&gt;即使選擇的程式碼可以很好地執行1023個character，但對於長度超過89個character（不包括分隔符）的其他設計，還是更可取的。&lt;/p&gt;

&lt;h2 id=&quot;致謝--acknowledgements&quot;&gt;致謝 ｜ Acknowledgements&lt;/h2&gt;

&lt;p&gt;本文件的靈感來自Rusty Russell的&lt;a href=&quot;https://rusty.ozlabs.org/?p=578&quot;&gt;address proposal&lt;/a&gt;，Mark Friedenbach的&lt;a href=&quot;https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-February/004402.html&quot;&gt;base32&lt;/a&gt;提案，並引用了Luke Dashjr，Johnson Lau，Eric Lombrozo，Peter Todd和其他各種審閱者的意見。&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">BIP: 173 Layer: Applications Title: Base32 address format for native v0-16 witness outputs Author: Pieter Wuille &amp;lt;pieter.wuille@gmail.com&amp;gt; Greg Maxwell &amp;lt;greg@xiph.org&amp;gt; Comments-Summary: No comments yet. Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0173 Status: Final Type: Informational Created: 2017-03-20 License: BSD-2-Clause Replaces: 142</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/124.png" /></entry><entry><title type="html">隔離見證、閃電網路概述</title><link href="http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89-%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0/" rel="alternate" type="text/html" title="隔離見證、閃電網路概述" /><published>2019-11-10T00:00:00+08:00</published><updated>2019-11-10T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89%E3%80%81%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0</id><content type="html" xml:base="http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89-%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/隔离见证、闪电网络理解.html&quot;&gt;原文&lt;/a&gt;：隔离见证、闪电网络理解  &lt;br /&gt;
隔離見證已經於2017年8月在比特幣上啟動了。最近比特幣正在朝著下一個擴容方案努力，閃電網路 Lightning Network。閃電網路的啟動必須基於更多的使用者使用隔離見證地址。&lt;/p&gt;

&lt;h3 id=&quot;源起&quot;&gt;源起&lt;/h3&gt;

&lt;p&gt;現在的比特幣網路交易量特別大，但是區塊10分鐘一個，一個區塊限制1M大小，這就造成了比特幣網路的擁堵。如果大家瞭解交易結構就一定知道加解密指令碼，這些指令碼都是放在區塊裡面的，於是大家就想如何能把指令碼從區塊中拿出來單獨儲存，這樣一個區塊不就可以容納更多的交易了嗎？於是下圖的結構就出現了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/125.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;隔離見證的其中一個好處是能緩解我們交易堵塞的問題。但是最重要的是為了閃電網路鋪路。一種建立在比特幣底層網路的智慧合約。&lt;/p&gt;

&lt;p&gt;隔離驗證確實不是很好的解決之道，因為指令碼還是需要儲存的，沒有指令碼的交易，那麼這個交易是不是可以隨便花費。另外對於錢包節點都是要去檢查指令碼的準確性，這個還是需要有指令碼資料的，所以這個也不是簡單的事情吧！&lt;/p&gt;

&lt;h3 id=&quot;分叉&quot;&gt;分叉&lt;/h3&gt;

&lt;p&gt;隔離見證可以應用軟分叉或者硬分叉，當然最終實施的是軟分叉。新的節點是可以相容後者的，但是舊節點是不是相容新版本的區塊這個是需要考慮的，如果不相容那麼就肯定出現軟分叉。但是官方的說明是舊版本的節點不用升級，這句話的話外之音就是舊節點也是支援新版的區塊（包含隔離見證）。看來這項技術很好。至於BCH應該是人為的硬分叉了。這部分知識可參考隔離見證比任何硬分叉都高階&lt;/p&gt;

&lt;p&gt;上篇的文章中提到了Core團隊很多的問題，也許確實有問題，但是作為開發者，考慮前後版本相容也是應該的，畢竟誰都不想出問題。另外還有一點就是一旦一個項目上線，可做的可能真的就不多了，一是改動複雜，程式設計師不想動，二是工作量比較大！對於這場戰爭我還是當個第三者吧，看慣了公司風風雨雨，拿刀開乾的人還是很少的。一旦變革失敗也不會有人同情，core團隊可能有自己的考量。畢竟對於資本市場來說一切都是那麼的浮躁。&lt;/p&gt;

&lt;h2 id=&quot;閃電網路&quot;&gt;閃電網路&lt;/h2&gt;

&lt;p&gt;閃電網路提供了一個可擴充套件的微支付通道網路。交易雙方若在區塊鏈上預先設有支付通道，就可以多次、高頻、雙向地通過軋差方式實現瞬間確認的微支付；雙方若無直接的點對點支付通道，只要網路中存在一條連通雙方的、由多個支付通道構成的支付路徑，閃電網路也可以利用這條支付路徑實現資金在雙方之間的可靠轉移。&lt;/p&gt;

&lt;p&gt;上面的這段話可能比較難於理解，總的來說就是通過多簽名實現多重交易的劃分，這裡需要了解比&lt;a href=&quot;http://gavinzhang.work/2018/03/16/blockchain/bitcoin%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/&quot;&gt;特幣的智慧合約&lt;/a&gt;和&lt;a href=&quot;http://gavinzhang.work/2018/03/17/blockchain/bitcoin%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/&quot;&gt;P2SH指令碼&lt;/a&gt;的相關知識。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;閃電網路並不試圖解決單次支付的銀貨對付問題，其假設是單次支付的金額足夠小，即使一方違約另一方的損失也非常小，風險可以承受。因此使用時必須注意“微支付”這個前提。多少資金算“微”，顯然應該根據業務而定。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;技術本質&quot;&gt;技術本質&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;閃電網路的關鍵技術有三，後後依賴於前前，依次是：RSMC，HTLC和閃電網路。技術實現雖然複雜，但本質卻很簡單。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RSMC解決了通道中幣單向流動問題，HTLC解決了幣跨節點傳遞的問題。這兩個類型的交易組合構成了閃電網路。這裡面還會用到我們之前提到的&lt;a href=&quot;http://gavinzhang.work/2018/03/26/blockchain/BIP-65%20OP-CHECKLOCKTIMEVERIFY/&quot;&gt;BIP-65 OP_CHECKLOCKTIMEVERIFY&lt;/a&gt;和&lt;a href=&quot;http://gavinzhang.work/2018/03/26/blockchain/BIP-68%E4%BD%BF%E7%94%A8%E5%85%B1%E8%AF%86%E5%BA%8F%E5%88%97%E5%8F%B7%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%AF%B9%E9%94%81%E5%AE%9A%E6%97%B6%E9%97%B4/&quot;&gt;BIP-68使用共識序列號記錄相對鎖定時間&lt;/a&gt;，這兩篇文件提到了交易鎖定的問題，也提到了分叉的問題。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;rsmc&quot;&gt;RSMC&lt;/h3&gt;

&lt;p&gt;我們先來建立一個序列到期可撤銷合約（RSMC），Alice和Bob是合作方，經常有比特幣往來，所以他們決定各拿出0.5BTC放入 &lt;strong&gt;通道&lt;/strong&gt; 中，便於業務往來。解釋一下下方RSMC交易的結構（圖X），左側為Alice的視角，右側為Bob的視角。中間Funding Tx為共同可見，C1a和RD1a為Alice持有，C1b和RD1b為Bob持有。交易圖中帶有尖括號的簽名表示待填入。&lt;/p&gt;

&lt;h4 id=&quot;建立交易&quot;&gt;建立交易&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/126.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;來對上面的圖進行一番解釋：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;雙方各拿出0.5BTC，構建Funding Tx，輸出為Alice和Bob的2/2多重簽名。此時，Funding Tx未簽名，更不廣播。&lt;/li&gt;
  &lt;li&gt;Alice構造Commitment Tx：C1a和RD1a，並交給Bob簽名。C1a的第一個輸出為多重簽名地址，Alice的另一把私鑰Alice2和Bob的2/2多重簽名，第二個輸出為Bob 0.5BTC。&lt;/li&gt;
  &lt;li&gt;RD1a為C1a第一個輸出的花費交易，輸出給Alice0.5BTC，但此類型交易帶有sequence，作用是阻止當前交易進塊，只有前向交易有sequence個確認時才能進塊。&lt;/li&gt;
  &lt;li&gt;Bob構造Commitment Tx：C1b和RD1b，並交給Alice簽名。結構與C1a、RD1a是對稱關係。&lt;/li&gt;
  &lt;li&gt;Bob對C1a和RD1a進行簽名，並將簽名給Alice；同理，Alice對C1b和RD1b簽名，完成後給Bob。此時，由於並未對Funding Tx進行簽名，任何一方均無法作惡，任何一方也不會有任何損失。&lt;/li&gt;
  &lt;li&gt;雙方均完成對commitment Tx的簽名並交換後，各自再對Funding Tx進行簽名，並交換。此時，Funding Tx是完整的交易，廣播之。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述過程以及結構圖的描述，就是建立RSMC的全部過程。C1a, C1b兩筆交易花費的是同一個輸出，故他們兩個交易只有一個能進塊。若Alice廣播C1a，則Bob立即拿到0.5BTC（C1a的第二個輸出），而Alice需要等C1a得到1000個確認，才能通過RD1a的輸出拿到0.5BTC。另一方，若Bob廣播C1b，則Alice立即拿到0.5BTC，Bob等待C1b得到1000個確認，才能通過RD1b拿到0.5BTC。也就是說，單方廣播交易終止合約的那一方會延遲拿到幣，而另一放則立即拿幣。&lt;/p&gt;

&lt;h4 id=&quot;交易更新&quot;&gt;交易更新&lt;/h4&gt;

&lt;p&gt;Alice和Bob各自0.5BTC的餘額，此時Alice從Bob處購買了一件商品，價格為0.1BTC，那麼餘額應該變為Alice 0.4BTC，Bob 0.6BTC。於是建立新的Commitment Tx，對於Alice來說是C2a 和RD2a，對於Bob來說是C2b和RD2b，過程與上面類似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/127.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此時兩個狀態均是有效的，那麼最核心的問題來了，如何才能徹底廢棄掉C1a和C1b呢？
RSMC採用了一個非常巧妙的方法，在C1a的第一個輸出中，採用了Alice2和Bob的多重簽名，Alice將Alice2的私鑰交給Bob，即表示Alice放棄C1a，承認C2a。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/128.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Alice交出Alice2的私鑰給Bob，那麼Bob就可以修改RD1a的輸出給他自己，形成新的交易BR1a。若Alice破壞合約存在C2a的情況下依然廣播出C1a，那麼Alice的懲罰就是失去她全部的幣。Alice交出Alice2的私鑰，或者對交易BR1a進行簽名，兩者是等同的，都是對C1a的放棄。反之亦然，Bob交出Bob2的私鑰給Alice即意味放棄C1b，而僅能認可C2b。引入sequence的目的是，阻止後續交易進塊（RD1a），給出一個實施懲罰視窗期，當發現對方破壞合約時，可以有1000個塊確認的時間去實施懲罰交易，即廣播BR1a代替RD1a。若錯過1000個塊時間視窗，則無法再實施懲罰了（RD1a進塊了）。&lt;/p&gt;

&lt;h4 id=&quot;交易關閉&quot;&gt;交易關閉&lt;/h4&gt;

&lt;p&gt;關閉RSMC，直接按照最終的餘額構造出一個Commitment TX即可，例如輸出為Alice0.1BTC，Bob0.9BTC，無需再設定多重簽名，構造懲罰交易等。&lt;/p&gt;

&lt;h4 id=&quot;中轉交易真實的閃電網路htlc&quot;&gt;中轉交易（真實的閃電網路，HTLC）&lt;/h4&gt;

&lt;p&gt;我們來看一下基本的流程圖吧！
&lt;img src=&quot;/img/129.png&quot; alt=&quot;&quot; /&gt;
這裡面的R就是支付的口令，其實就是交易節點之間沒有直連的通道，需要其他人待轉，這些人會收手續費。這裡面需要解決幾個問題（我的思考）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何建立初始的支付通道&lt;/li&gt;
  &lt;li&gt;如果兩個節點間無直接支付通道，如何找到最佳的支付通道。&lt;/li&gt;
  &lt;li&gt;如何保證第三方不作弊，防止現金丟失（前面的講的都是這個問題）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;總結&quot;&gt;總結&lt;/h3&gt;

&lt;h4 id=&quot;rsmc-1&quot;&gt;RSMC&lt;/h4&gt;

&lt;p&gt;閃電網路的基礎是交易雙方之間的雙向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定義了該雙向微支付通道的最基本工作方式。這是要求雙方都拿出資金放到合約上，然後輸出動態分配，最後確認輸出後上鏈，這樣的好處就是支付完全是在鏈下執行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;為了鼓勵雙方儘可能久地利用通道進行交易，RSMC對主動終止通道方給予了一定的懲罰：主動提出方其資金到賬將比對方晚，因此誰發起誰吃虧。這個設計雖然增加了技術複雜度，但應該說是合理的。&lt;/strong&gt;  這樣許多交易就會在區塊鏈下面執行，不會產生交易（只產生預備交易），最後交易才會上鍊。還有就是交易的憑證怎麼保證？所以這個方式或許也有很多技術和現實的缺陷所在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通道餘額分配方案的本質是結算準備金。在此安排下，因為要完全控制資金交收風險，每筆交易都不能突破當前結算準備金所施限制。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;htlc&quot;&gt;HTLC&lt;/h4&gt;

&lt;p&gt;RSMC只支援最簡單的無條件資金支付，HTLC（Hashed Timelock Contract）進一步實現了有條件的資金支付，通道餘額的分配方式也因此變得更為複雜。&lt;/p&gt;

&lt;p&gt;通過HTLC，Alice和Bob可以達成這樣一個協議：協議將鎖定Alice的0.1 BTC，在時刻T到來之前（T以未來的某個區塊鏈高度表述），如果Bob能夠向Alice出示一個適當的R（稱為祕密），使得R的雜湊值等於事先約定的值H(R)，Bob就能獲得這0.1 BTC；如果直到時刻T過去Bob仍然未能提供一個正確的R，這0.1 BTC將自動解凍並歸還Alice。&lt;/p&gt;

&lt;h2 id=&quot;雷電網路&quot;&gt;雷電網路&lt;/h2&gt;

&lt;p&gt;基於閃電網路的思路，以太坊社群也提出了自己的鏈下微支付通道解決方案：雷電網路（Raiden Network）。
延續了以太坊的風格，把本來較簡單的問題複雜智慧化。大致與閃電網路相同，但細節有些地方更復雜。例如：第一層面的那個舊版本作廢，其實只要加上時間戳看哪個時間新就可以了。但是其額外增加了一個單增的Sequence Number欄位來標明哪個有效。還有記錄分配餘額即可，但雷電網路記錄的是增減變動量。在第二個層面上，雷電網路引入了較HTLC更通用和複雜的“Smart Condition”。就是說HTLC中採用的成熟簡單地求HASH函數，在雷電網路中替代成了使用者可自己設定的任意函數，就是說向外擴充套件了，更加智慧，但同時面臨的風險可能就越大。&lt;/p&gt;

&lt;h2 id=&quot;corda&quot;&gt;Corda&lt;/h2&gt;

&lt;p&gt;相近技術的低層思想是相通的，受到閃電網路思想的啟發，知名的R3也宣佈釋出非區塊鏈的分散式賬本應用Corda，其本質思想應該是與閃電網路較相近似。
關於Corda的資料較少，如整個R3較閉源封閉一樣，只是R3 CEV的首席技術官Richard Brown之前在部落格中披露些Corda的主要特點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;沒有多餘的全局資料共享：有合法需求的參與方才可按照協議獲取資料；&lt;/li&gt;
  &lt;li&gt;Corda編寫和配置在企業間流轉，無中心控制者；&lt;/li&gt;
  &lt;li&gt;Corda在企業間單個交易水平達成共識，而不是在系統水平上；&lt;/li&gt;
  &lt;li&gt;系統設計直接支援監管觀察員節點；&lt;/li&gt;
  &lt;li&gt;交易直接由交易雙方驗證，而不是由一大群不相干的驗證者進行；&lt;/li&gt;
  &lt;li&gt;支援多種共識機制；&lt;/li&gt;
  &lt;li&gt;記錄了智慧合約程式碼和人類語言法律檔案的清晰聯絡；&lt;/li&gt;
  &lt;li&gt;用行業標準工具建立；&lt;/li&gt;
  &lt;li&gt;沒有原始加密貨幣。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;總結-1&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;將交易和智慧合約的執行放在鏈下快速地執行，僅在必要時才將其在鏈上公開結算執行，這就是閃電網路帶給我們的絕佳思路。同時可增加對閃電結鏈上算時的手續費，減輕鏈上壓力的同時有可能提升礦工收入，因理論上不可能所有交易都閃電。比特幣主鏈上交易有其它任何形式鏈下交易或側鏈交易所無法替代的優點。&lt;/p&gt;

&lt;h2 id=&quot;參考和引用&quot;&gt;參考和引用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32613487&quot;&gt;三分鐘讓你瞭解什麼是Segwit隔離見證&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chainnode.com/post/45833&quot;&gt;隔離見證比任何硬分叉都高階&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.8btc.com/article/95385&quot;&gt;比特幣擴容為什麼選擇2MB？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/46515457&quot;&gt;什麼是比特幣的閃電網路？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/58567061&quot;&gt;什麼是隔離見證？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.8btc.com/article/92887&quot;&gt;詳解最近大熱的閃電網路、雷電網路和CORDA&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/lM0p3ikVBdw1zE50IWtMZA&quot;&gt;6.9Bite醬一閃電網路⚡大白話零門檻講解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：隔离见证、闪电网络理解 隔離見證已經於2017年8月在比特幣上啟動了。最近比特幣正在朝著下一個擴容方案努力，閃電網路 Lightning Network。閃電網路的啟動必須基於更多的使用者使用隔離見證地址。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/125.png" /></entry><entry><title type="html">以區塊鏈為基礎的電子化註冊交付服務</title><link href="http://localhost:4000/news/2019/11/09/%E7%BF%BB%E8%AD%AF-%E4%BB%A5%E5%8D%80%E5%A1%8A%E9%8F%88%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E9%9B%BB%E5%AD%90%E5%8C%96%E8%A8%BB%E5%86%8A%E4%BA%A4%E4%BB%98%E6%9C%8D%E5%8B%99/" rel="alternate" type="text/html" title="以區塊鏈為基礎的電子化註冊交付服務" /><published>2019-11-09T00:00:00+08:00</published><updated>2019-11-09T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/09/%E7%BF%BB%E8%AD%AF:%E4%BB%A5%E5%8D%80%E5%A1%8A%E9%8F%88%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E9%9B%BB%E5%AD%90%E5%8C%96%E8%A8%BB%E5%86%8A%E4%BA%A4%E4%BB%98%E6%9C%8D%E5%8B%99</id><content type="html" xml:base="http://localhost:4000/news/2019/11/09/%E7%BF%BB%E8%AD%AF-%E4%BB%A5%E5%8D%80%E5%A1%8A%E9%8F%88%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E9%9B%BB%E5%AD%90%E5%8C%96%E8%A8%BB%E5%86%8A%E4%BA%A4%E4%BB%98%E6%9C%8D%E5%8B%99/">&lt;blockquote&gt;
  &lt;p&gt;本篇文章翻譯自 &lt;a href=&quot;https://ieeexplore.ieee.org/document/8764454?source=post_page-----f0472420a45b----------------------&quot;&gt;IEEE - Blockchain-Based System for Multiparty Electronic Registered Delivery Services&lt;/a&gt; 的內容，歐洲法規規定了電子化支付（電子化識別和信任服務）而一個合格的電子註冊交付是信託服務之一並包含在法規中，它要求不可否認原產地及誠信的資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;摘要&quot;&gt;摘要&lt;/h1&gt;

&lt;h2 id=&quot;故事介紹&quot;&gt;故事介紹&lt;/h2&gt;

&lt;p&gt;歐洲法規規定了電子化支付（電子化識別和信任服務）而一個合格的電子註冊交付是信託服務之一並包含在法規中，它要求不可否認原產地及誠信的資料。這些服務基本上會依賴於信任的第三方，仍會有很大的溝通及使用障礙。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;科普小學堂 
「若想要讀得更詳細，請參閱最底下資料來源」
1. 交付：交付是動產、物權變動的公示方式。動產種類繁多，數量巨大，變動頻繁，不適宜採用登記方式。
2. 信託：委託人將財產權移轉或為其他處分，使受託人依信託本旨，為受益人之利益或為特定之目的，管理或處分信託財產之關係。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;edelivery&quot;&gt;eDelivery&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在文章中，作者採用區塊鏈技術來解決問題（將 eDelivery 計劃減少受信任的第三方），並且滿足歐盟註冊 eDeliveries 的規範。&lt;/li&gt;
  &lt;li&gt;由於機密性不被視為強制性財產，作者提出了兩個協議。
    &lt;ul&gt;
      &lt;li&gt;第一個：適合不太在乎消息或資料機密性，甚至是可以公開訪問的。&lt;/li&gt;
      &lt;li&gt;第二個：允許除了接收方以外，隱藏他人的消息。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第一章節---介紹&quot;&gt;第一章節 - 介紹&lt;/h1&gt;

&lt;p&gt;區塊鏈提供了一個不可修改的資料註冊系統，可為傳統應用程式提供新的解決方案。
&lt;em&gt;舉例：經過認證的電子郵件帳號，可以經過區塊鏈技術來證明他已發送信件或其他類型的服務。&lt;/em&gt;
在之前，為了解決傳遞中之公平性問題，皆會透過 TTP（Trusted Third Party , 可信任之第三方）來解決。在典型的 eDelivery 案例中，要交換的是資料以及不可否認之來源證明。&lt;/p&gt;

&lt;h2 id=&quot;a-合格的電子註冊遞送系統&quot;&gt;A. 合格的電子註冊遞送系統&lt;/h2&gt;

&lt;p&gt;2016年7月，歐盟信息安全網的法規 910/2014（也稱為 eIDAS 法規）開始適用。該法規為內部市場的電子交易制定了電子識別和信託服務規則，涵蓋了所有28個成員國。&lt;/p&gt;

&lt;p&gt;文件（Document）中定義了幾種信任服務：&lt;strong&gt;電子簽名（Electronic Signature）、密封（Seals）、時間戳記（TimeStamps）、已註冊的交付服務和用於網站驗證的證書&lt;/strong&gt;。該法規引入了合格信託服務和合格信託服務提供商的概念，其中包含確保信託服務高級別安全性的要求和義務。&lt;/p&gt;

&lt;p&gt;合格的 eDelivery 服務必須根據指令提供：&lt;em&gt;資料/數據完整性、來源認證、交付時間的認證&lt;/em&gt;，而其中機密性不被視為核心功能但通常作為更完整的解決方案。&lt;/p&gt;

&lt;p&gt;eDelivery 服務定義的資料 / 數據稱之為「Message（消息）」，且包含經過認證的通知和電子郵件。而電子郵件是一種可以使用的傳輸方式，但是 eDelivery 並不僅限於電子郵件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;eDelivery 實例介紹&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;註冊過的電子郵件，能提供更多與處理電子郵件相關的證據&lt;/li&gt;
  &lt;li&gt;訪問和交換敏感的資訊&lt;/li&gt;
  &lt;li&gt;事件的電子化公證&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;b-交換協議中的安全性和可信任之第三方&quot;&gt;B. 交換協議中的安全性和可信任之第三方&lt;/h2&gt;

&lt;p&gt;至今所提出的交換協議（例如電子郵件服務）的操作通常使用 TTP ，其負責解決由於交換或詐欺而引起的衝突。&lt;/p&gt;

&lt;p&gt;當前的公平交換協議，包括 TTP 之干預以及很難為網路中用戶提供真正可靠的 TTP ，且具有明確的框架（例如，TTP 生成的電子文件必須被法院接受才能解決事件上的爭議）。&lt;/p&gt;

&lt;p&gt;TTP 也有可能在技術層面遇到問題（例如：通信容易遇到瓶頸、協議缺乏效率），並且他們的可靠性也容易遇到挑戰，如果他們有任何漏洞，交換協議中的安全性即會被打破。&lt;/p&gt;

&lt;h2 id=&quot;c-區塊鏈的解決方案&quot;&gt;C. 區塊鏈的解決方案&lt;/h2&gt;

&lt;p&gt;隨著區塊鏈技術以及智能合約（Smart Contract）的出現，TTP 可以被這種新的技術所取代或補充，這為尋找解決方案提供了新的可能性。&lt;/p&gt;

&lt;p&gt;智能合約能減少對 TTP 的需求，他是一種運行在區塊鏈上的程式，以預先訂立的規則來執行交易，這可以保障雙方之間的公平交換和相互信任，並且可防止互相欺騙且從而減少傳遞訊息中的延遲及服務佣金。&lt;/p&gt;

&lt;p&gt;區塊鏈中的時間戳記（Timestamps）對於協議中的公平性是至關重要的！&lt;/p&gt;

&lt;h1 id=&quot;第二章節---註冊-edelivery-之理想屬性&quot;&gt;第二章節 - 註冊 eDelivery 之理想屬性&lt;/h1&gt;

&lt;p&gt;底下將會介紹關於 eDelivery 的主要功能列表&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;法律相關 Legal Features&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;交貨證明：發送方收到不可偽造的時間戳記，證明他已經傳遞訊息。&lt;/li&gt;
  &lt;li&gt;接收證明：雙方皆收到不可偽造的時間戳記。&lt;/li&gt;
  &lt;li&gt;誠信證明：雙方皆可以確保傳輸過程中沒有被竄改。&lt;/li&gt;
  &lt;li&gt;安全性：防止丟失、被盜或未經授權之更改。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;安全相關 Security Features&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;發送人識別：消息接收方可以驗證發送方。&lt;/li&gt;
  &lt;li&gt;安全的時間戳記：此時間戳記提供交付日期和時間準確性。&lt;/li&gt;
  &lt;li&gt;保密：雙方皆可確定未經授權的人員無法訪問該訊息。&lt;/li&gt;
  &lt;li&gt;資料完整性：確保傳輸資料的完整性，即消息之內容。&lt;/li&gt;
  &lt;li&gt;控制路由錯誤：該控制有助於傳輸前檢查接受器之參數，並告知用戶傳輸前接收消息的能力。&lt;/li&gt;
  &lt;li&gt;互操作性：服務向發送方指示預期接收方可以儲利的格式消息，並將消息轉換為另種格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;功能相關 Function Features&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;發送大文件：該服務必須允許傳輸大量消息和各種格式的消息。&lt;/li&gt;
  &lt;li&gt;快速處理：必須是即時的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;其他 Other Properties&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;降低風險：合格的電子註冊交付使得以下操作變得不可行（操縱數據、偽造發送和接收的時間戳記或未授權訪問）。&lt;/li&gt;
  &lt;li&gt;降低成本：降低失敗或不確定性的成本。&lt;/li&gt;
  &lt;li&gt;沒有傳輸延遲：傳輸必須幾乎是瞬間的。&lt;/li&gt;
  &lt;li&gt;沒有雙重支付：避免發送額外的簽名版本。&lt;/li&gt;
  &lt;li&gt;事故處理和責任：服務提供商仍要對客戶造成的損害承擔責任。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;考慮了上述功能，以便列出 eDelivery 系統的安全屬性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;有效性：如果雙方行為正確，他們將收到預期的項目。&lt;/li&gt;
  &lt;li&gt;公平性：完成協議運行後，每一方將會收到預期的項目，或者任一方皆沒收到任何一方的有效訊息。&lt;/li&gt;
  &lt;li&gt;時效性：在協議運行期間，每一方皆可以單方面選擇終止協議而不會失去公平性。&lt;/li&gt;
  &lt;li&gt;不可否認性：如果物品從 A 發送到 B ，則 A 不能拒絕該物品的來源，B 不能拒絕接收該物品。&lt;/li&gt;
  &lt;li&gt;第三方可驗證性：如果第三方行為不好，導致一方喪失公平，受害者可以爭議中證明此事實。&lt;/li&gt;
  &lt;li&gt;保密性：只有資料的發送及接收方才知道認證消息的內容。&lt;/li&gt;
  &lt;li&gt;效率：有效的協議使用允許有效交換或最小成本的最少步驟數。&lt;/li&gt;
  &lt;li&gt;證據可轉移性：系統生成的證據可以轉移到外部，以證明交換的結果。&lt;/li&gt;
  &lt;li&gt;狀態存儲：如果不需要可以參與交換的 TTP 來維護狀態訊息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述解釋了不可否認的階段：證據生成、證據轉移、證據驗證、證據存儲和解決爭議。&lt;/p&gt;

&lt;h1 id=&quot;第三章節---註冊電子服務當前發展&quot;&gt;第三章節 - 註冊電子服務當前發展&lt;/h1&gt;

&lt;p&gt;作者調查了公平交換問題，提出兩種使用智能合約進行公平交換的解決方案，該方案由區塊鏈功能支持並使用圖靈完備語言。&lt;/p&gt;

&lt;p&gt;作者提出以區塊鏈技術和以太坊智能合約之不可否認協議，此用於解決 Token 和 數字資產間的交易，此協議要求相關各方存放抵押品，以激勵行為者的誠實行為。&lt;/p&gt;

&lt;p&gt;作者也提出一個可重複使用的智能合約概念，它用於發送多個通知。&lt;/p&gt;

&lt;h1 id=&quot;第四章節---貢獻&quot;&gt;第四章節 - 貢獻&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;（略）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第五章節---系統總覽&quot;&gt;第五章節 - 系統總覽&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;參與者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;發送方&lt;/li&gt;
  &lt;li&gt;接收方&lt;/li&gt;
  &lt;li&gt;可信任的第三方&lt;/li&gt;
  &lt;li&gt;智能合約&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有參與者皆擁有 address 並且能夠相互溝通以及和智能合約溝通。
兩個提議的協議都遵循 3-Steps 交換。關於這個 3-Steps 協議的非機密和機密解決方案之間的主要區別在於，在機密解決方案中，各方可以直接交換消息（離線通信交換），而在非機密解決方案中，各方執行 3-Steps ，通過調用為此服務部署的智能合約的功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;圖1 描述了非機密協議的參與者之間的鏈間交互&lt;/li&gt;
  &lt;li&gt;圖2 中描述了機密協議的離線交互。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/93.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖1 非機密協議中的參與者之間的互動&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/94.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖2 機密協議中的參與者之間的互動&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;第六章節---基於非機密區塊鏈的多方註冊電子交付系統&quot;&gt;第六章節 - 基於非機密區塊鏈的多方註冊電子交付系統&lt;/h1&gt;

&lt;p&gt;此方法非常適合需要儲存交付數據的應用程序，這些應用程序必須註冊並可公開訪問。&lt;/p&gt;

&lt;p&gt;非機密註冊 eDeliveries 的多方協議提供了一個發送方（A）和多個接收方（B = {B1，B2 …，Bn}）的公平交付解決方案。&lt;/p&gt;

&lt;p&gt;圖3 是發送方和接收方在非機密 eDelivery 中為所提出的鏈上通信方案交換的消息序列圖。
在圖3中，藍色箭頭表示上述步驟，並指定對區塊鏈地址的簽名請求。&lt;/p&gt;

&lt;p&gt;此外，框內的紅色文本描述了必須由區塊鏈上部署的 eDelivery 執行的過程。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;800&quot; src=&quot;/img/95.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖3 基於非機密區塊鏈的協議描述&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;交付的發送方 A 和接收方集合 B 將遵循交換協議的步驟。
在以下對協議的完整描述中，協議的參與者發送的請求被指向區塊鏈上部署的 eDelivery 服務的地址。&lt;/p&gt;

&lt;p&gt;交換協議的細節是（表1中的表示法）：
發送方 A 發送新的 eDelivery 請求。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;該請求包括發送方的 Address，要傳遞的消息的 Hash（c，該 Hash 也用作 eDelivery 的識別），- 接收方的地址以及句號 term1 和 term2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;`&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;term1 為接收方在發送方完成交付前，能接受交付的有效期限。&lt;/li&gt;
  &lt;li&gt;term2 為允許接收方取消，未完成交付的期限。
`&lt;/li&gt;
  &lt;li&gt;取消的功能是為了保證有效性和公平性。&lt;/li&gt;
  &lt;li&gt;B 中的每個接收方 Bi 必須在 term1 期間單獨接受傳遞的接收，發布表達其意願的消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;簽署的交易將作為接收證明的不可否認性。&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果接收方在 term1 期間不接受，則假定拒絕。&lt;/li&gt;
  &lt;li&gt;在 term1 的截止日期之後，或者在所有接收方（B的成員）接受了接收之後，發送方A可以通過使用區塊鏈發布消息，完成與已接受的接收方B’（B’⊂B）的子集的傳遞。&lt;/li&gt;
  &lt;li&gt;因此，部署在區塊鏈上的 eDelivery 服務會檢查消息的完整性，並為 B’ 中的接收方發布原始證據的不可否認性。完成後，發送方將收到押金退款。&lt;/li&gt;
  &lt;li&gt;在這種情況下，我們在一般的 3-Steps 協議中添加了最後一步：在 term2 的截止日期之後， B’ 中的任何接收方都可以獲取消息，或者可以請求取消 eDelivery，以防消息未正確存入。&lt;/li&gt;
  &lt;li&gt;最後執行完交換協議之後，所有接收方都可以讀取消息 M，因為它存在區塊鏈中，但只有 B’ 的成員可以證明他們已被通知且有證據。&lt;/li&gt;
  &lt;li&gt;如果 term2 之後，發送方尚未發布消息，則每個接收方 Bi 可以取消 eDelivery 。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/96.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;表1 非機密協議之要素&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;第七章節---基於機密區塊鏈的註冊-edelivery-協議&quot;&gt;第七章節 - 基於機密區塊鏈的註冊 eDelivery 協議&lt;/h1&gt;

&lt;p&gt;第二項提案的設計考慮到了需要保密的交付。&lt;/p&gt;

&lt;p&gt;也就是說，區塊鏈必須有助於保持交換的公平性，但是消息不能存儲在公開訪問的區塊中。
與非機密案例的主要區別在於，在機密案例中，協議允許進行離線交換，所以交換可以在沒有區塊鏈或 TTP 干預的情況下執行。&lt;/p&gt;

&lt;p&gt;另一個重要特徵是該提案不需要截止日期，任何交換都可以隨時完成。無國籍 TTP 可用於解決雙方之間可能產生的爭議。我們描述了一種基於非區塊鏈的公平交換，我們將部分重用（即鏈下 3-Steps 交換），並在套用在本節中基於區塊鏈的新提案。&lt;/p&gt;

&lt;p&gt;在新協議中，發送方 A 和收件方 B 直接交換消息和不可否認證據，使用圖4 中描述的 3-Steps 脫鏈通信。僅作為最後手段，以防他們無法獲得預期通過發送取消請求（圖5）或完成請求（圖6），可以調用來自另一方，智能合約或TTP的項目。&lt;/p&gt;

&lt;p&gt;描述的協議相比，基於區塊鏈的解決方案中 TTP 的作用已大大降低。此外，發送方永遠不會聯繫 TTP。
在這個新提案中，TTP 將僅採用已部署的智能合約來回應 B 的請求。TTP 完全是無狀態的，因此它從不存儲有關任何交換狀態的信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;圖中的藍色箭頭表示對區塊鏈地址的簽名請求，而黑色箭頭表示離線通信消息。&lt;/code&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600&quot; src=&quot;/img/97.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;表2 機密多方協議之要素&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;a-多重之正向交換子協議&quot;&gt;A. 多重之正向交換子協議&lt;/h2&gt;

&lt;p&gt;該協議在某種意義上是正向的，發送方 A 有可能在沒有 TTP 干預的情況下完成接收方集合 B 的交換。&lt;/p&gt;

&lt;p&gt;圖 4. 由機密 eDelivery 發送方和接收方交換的 3-Steps，已通過正向方法解決交換：該協議在某種意義上是正向的，即發送方 A 有可能在沒有 TTP 干預的情況下完成與接收方 B 的交換。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;700&quot; src=&quot;/img/98.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖四 鏈下通信交換子協議&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;交換如下：發送方向接收方集合發送消息，包括加密消息，接收者的地址和原始證據的不可否認性的第一部分，kT、hA。&lt;/p&gt;

&lt;p&gt;每個接收者決定他是否發送不可否認接收證明 hBi 的交換。
接收方將接收打開消息的密鑰和原始證據的不可否認部分 kA。&lt;/p&gt;

&lt;p&gt;如果已成功完成這些步驟的執行，則發送方將持有來自所有接收方的不可否認接收（NRR）證據，並且每個接收方將持有該消息和不可否認原產地（NRO）證據。&lt;/p&gt;

&lt;p&gt;每個接收者都有密鑰，因此他可以解密消息，然後集合B的每個接收者獲得用於解密消息的密鑰 kA，以及相應的 NRO 證據（hA）。以相同的方式，消息的發送方將從每個接收者獲得 NRR 證據（hBi）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這樣，協議允許正向交換，也就是說，交換可以完全執行而無需 TTP和區塊鏈的干預。另一個重要特徵是該提案不需要截止日期，並且可以隨時完成，如果雙方之間發生爭議，可以執行以下子協議。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;b-多方之取消子協議&quot;&gt;B. 多方之取消子協議&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;取消子協議將由消息的發送方發起。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果沒從消息的所有接收方接收 hBi ，則發送方執行智能合約的相應功能。
在圖 5 中，有一個圖形描述，表明發送方和區塊鏈為取消未完成的接收方取消機密 eDelivery 所採取的行動。&lt;/p&gt;

&lt;p&gt;Hash H（c）用作 eDelivery 的識別碼。當發送方執行智能合約的取消功能時，她必須指出所有未發送 hBi 的用戶的身份（由集合 B’’ 表示）。就智能合約而言，它將負責檢查集合 B’’ 中的任何用戶是否已通過 TTP 完成交換。在這種情況下，它會將相應的 NRR 證據（針對特定的 Bi）發送給發送方。否則，未完成的接收方將被包括在已取消的用戶組中（B’’ — 已取消）。因此，在此階段結束時，發送方 A 將與所有接收方完成公平交換，或者令人滿意，因為她已經收到了 hBi，或者因為取消了。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/99.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖5 鏈上取消子協議&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;c-多方完成子協議&quot;&gt;C. 多方完成子協議&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;將由任何接收方發起，在已發送相應的 hBi 但尚未接收到該元素以獲得密鑰 kA 的情況下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最終確定將由 TTP 根據從收件方 Bi 收到的請求進行。在檢查從 Bi 接收的所有不同參數的正確性之後，TTP 執行智能合約的完成功能（TTP 將 Bi 的 NRR 證據（hBi）提交給智能合約）。&lt;/p&gt;

&lt;p&gt;在圖6中，描述了收件方，TTP 和區塊鏈在異常情況下完成機密 eDelivery 所採取的操作。 TTP 基於區塊鏈中存儲的有關此 eDelivery 的信息。在此子協議中，智能合約檢查請求是否來自 TTP，然後驗證聲明的收件人是否已取消其郵件傳遞的用戶。在這種情況下，會發出適當的取消證據。否則，智能合約在區塊鏈中存儲收到的 hBi，並通過將 Bi 添加到 B’’ 來完成已完成此交換的用戶組 — 已完成。最後，TTP 將 kT 發送給 Bi，接收者能夠閱讀該消息並完成 NRO 證據。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;800&quot; src=&quot;/img/100.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖6 鏈上完成子協議&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;第八章節---智能合約&quot;&gt;第八章節 - 智能合約&lt;/h1&gt;

&lt;p&gt;本文採用了以太坊區塊鏈，因為它提供了比比特幣區塊鏈更豐富的功能，因為他們在完全分布式系統中支持使用圖靈完備語言的智能合約。
底下將以非機密 / 機密的協議來給大家展示一下相關的智能合約。&lt;/p&gt;

&lt;h2 id=&quot;非機密多方註冊-edelivery-協議的智能合約&quot;&gt;非機密多方註冊 eDelivery 協議的智能合約&lt;/h2&gt;

&lt;p&gt;底下將會展示各種功能的智能合約撰寫範例&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/101.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖7 Variables 屬性定義&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/102.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖8 接受 function&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/103.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖9 完成 function&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/104.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖10 取消 function&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;機密多方註冊edelivery協議的智能合約&quot;&gt;機密多方註冊eDelivery協議的智能合約&lt;/h2&gt;

&lt;p&gt;底下將會展示各種功能的智能合約撰寫範例&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/105.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖11 屬性以及建構子&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/106.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖12 取消 function&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/107.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖13 完成 function&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/108.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖14 新增接收方 function&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/109.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖15 非機密協議中的狀態生命週期&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;結論&quot;&gt;結論&lt;/h1&gt;
&lt;p&gt;歐法規定了電子交易的電子識別和信託服務規則。然後技術提案必須達到合格的法律要求。合格電子註冊交付的特徵是法規中包含的信託服務之一，與公平交換協議提供的特徵類似：不可否認來源和接收數據的完整性。因此，可以為註冊的 eDelivery 設計公平交換協議。然而，這種服務通常嚴重依賴於可信第三方的使用，並且成本高且效率低，並且必須驗證 TTP 的行為。&lt;/p&gt;

&lt;p&gt;在本文也採用了區塊鏈技術結合智能合約來將 TTP 減少甚至取消，並且透過機密與非機密之不同需求選擇需要採用何種協議，使得人員能夠透過智能合約來減少複雜的手續和流程並且將 TTP 的干預降到最低，實現服務的理想屬性，我們也得知在協議設計中結合基於區塊鏈的技術可以影響 TTP 的作用。&lt;/p&gt;

&lt;h1 id=&quot;資料來源&quot;&gt;資料來源&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.mbalib.com/zh-tw/%E4%BA%A4%E4%BB%98&quot;&gt;交付 — MBA智庫百科&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.trust.org.tw/tw/info/related-introduction/0&quot;&gt;信託是什麼？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ec.europa.eu/cefdigital/wiki/display/CEFDIGITAL/eDelivery&quot;&gt;eDelivery&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7&quot;&gt;互操作性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7&quot;&gt;作者團隊 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6&quot;&gt;智能合約&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">本篇文章翻譯自 IEEE - Blockchain-Based System for Multiparty Electronic Registered Delivery Services 的內容，歐洲法規規定了電子化支付（電子化識別和信任服務）而一個合格的電子註冊交付是信託服務之一並包含在法規中，它要求不可否認原產地及誠信的資料。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/130.png" /></entry><entry><title type="html">Neutrino：一種保護隱私的輕錢包協議</title><link href="http://localhost:4000/news/2019/11/09/Neutrino-%E4%B8%80%E7%A8%AE%E4%BF%9D%E8%AD%B7%E9%9A%B1%E7%A7%81%E7%9A%84%E8%BC%95%E9%8C%A2%E5%8C%85%E5%8D%94%E8%AD%B0/" rel="alternate" type="text/html" title="Neutrino：一種保護隱私的輕錢包協議" /><published>2019-11-09T00:00:00+08:00</published><updated>2019-11-09T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/09/Neutrino:%E4%B8%80%E7%A8%AE%E4%BF%9D%E8%AD%B7%E9%9A%B1%E7%A7%81%E7%9A%84%E8%BC%95%E9%8C%A2%E5%8C%85%E5%8D%94%E8%AD%B0</id><content type="html" xml:base="http://localhost:4000/news/2019/11/09/Neutrino-%E4%B8%80%E7%A8%AE%E4%BF%9D%E8%AD%B7%E9%9A%B1%E7%A7%81%E7%9A%84%E8%BC%95%E9%8C%A2%E5%8C%85%E5%8D%94%E8%AD%B0/">&lt;p&gt;如今， Lightning 風行一時，儘管這是一個令人興奮的發展，但用戶目前必須運行一個完整的節點才能進行交易。在本文中，將介紹Neutrino，這是一種新的協議，用於輕型client在保留隱私且不信任中央server的情況下獲取所需的數據。&lt;a href=&quot;https://bitcoinmagazine.com/articles/neutrino-privacy-preserving-light-wallet-protocol&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一點歷史&quot;&gt;一點歷史&lt;/h2&gt;
&lt;p&gt;中本聰（Satoshi Nakamoto）在2008年撰寫的原始白皮書中描述了一種稱為簡化付款驗證（SPV）的東西。SPV是輕型節點無需下載、驗證或儲存整個區塊鏈即可驗證付款的方式。這應該是輕錢包的基礎。不幸的是，原始的Bitcoin Core軟體未實現簡化付款驗證，因此，輕量級客戶無法訪問以隱私保護方式進行SPV所需的數據。&lt;/p&gt;

&lt;p&gt;在2013年，BIP0037被添加到Bitcoin Core以使SPV可行。BIP0037創建了網絡指令，使輕節點可以執行簡化的付款驗證。輕型節點現在可以要求證明特定交易發生在特定區塊中。這樣，輕型節點將不必信任server，但實際上可以驗證提供給它們的數據。&lt;/p&gt;

&lt;p&gt;為此，輕client向server提供了一個過濾器。然後，server對新區塊的所有交易運行篩選器，並將這些交易以及它們在該區塊中的證據報告給client。然後，客戶驗證證明並查看交易，以查看其中是否屬於錢包。&lt;/p&gt;

&lt;p&gt;不幸的是，BIP0037有一些缺點。除其他外，這被認為很難實施，大多數輕錢包選擇使用其他東西。例如，Electrum錢包使用其&lt;a href=&quot;http://docs.electrum.org/en/latest/protocol.html&quot;&gt;自己的專有協議&lt;/a&gt;，該協議不保護隱私。Mycelium錢包調用Mycelium公司運行的server。此外，還有一些拒絕服務媒介（通過運行大量過濾器）來利用響應BIP0037請求的server。&lt;/p&gt;

&lt;p&gt;此外，事實證明，BIP0037的隱私方面沒有想像的那麼強。事實證明，通過查找某些類型的模式，server可以對輕錢包有很多了解（例如它可能有什麼餘額，與誰進行交易，甚至可能是購買的東西）。&lt;/p&gt;

&lt;p&gt;因此，儘管自2013年以來已在Core軟體中使用BIP0037，但在很大程度上已經廢棄了。&lt;/p&gt;

&lt;h2 id=&quot;什麼是neutrino&quot;&gt;什麼是Neutrino？&lt;/h2&gt;
&lt;p&gt;Neutrino是一種驗證付款的協議，除了這次，大部分工作是在client完成的。現在代替server過濾client的交易，而是將屬於一個區塊的所有交易（技術上對應於除OP_RETURN輸出之外的每個輸入和輸出的ScriptPubKey）壓縮並發送給client。現在，客戶的工作是弄清是否有任何交易是它進行的交易。如果任何交易與電子錢包有關，則客戶然後請求完整的區塊來驗證交易。&lt;/p&gt;

&lt;p&gt;事實證明，壓縮效果令人印象深刻。正常區塊約為1.4MB，但是通過對其進行壓縮（從技術上講，將每個ScriptPubKey hash 為64位），每個區塊會在每個區塊上產生約20KB的超壓縮數據。由於每個超級client的超級壓縮區塊都相同，因此可以消除server的拒絕服務漏洞。這也意味著server除了要查看的阻止內容外，沒有獲得有關輕client的特殊訊息，這意味著隱私洩漏少得多。&lt;/p&gt;

&lt;h2 id=&quot;權衡取捨&quot;&gt;權衡取捨&lt;/h2&gt;
&lt;p&gt;當然，通過增加隱私權，我們確實需要權衡取捨。首先，有更多的數據來回發送。雖然1.4MB到20KB的帶寬減少了很多，但是BIP0037允許更大的減少，因為server只為錢包參與的交易發送大約3KB的數據區塊，而沒有這種交易的只有80 bytes 的數據區塊。假設每天大約有一筆交易，那麼BIP0037的每個區塊總計大約100 bytes ，這意味著從帶寬的角度來看Neutrino的價格更高。&lt;/p&gt;

&lt;p&gt;此外，由於client現在必須執行其他驗證以證明server發送的數據是真實的，因此在client需要進行更多的驗證。&lt;/p&gt;

&lt;p&gt;在尋找錢包參與的交易時會保留隱私。通常，這些交易是錢包正在收款的交易。然而，對於匯款來說，Neutrino並沒有真正幫助，仍然存在很多隱私問題（儘Tor和&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0156.mediawiki&quot;&gt;Dandelion&lt;/a&gt; 可以提供幫助）。&lt;/p&gt;

&lt;p&gt;最後，可能需要對每個區塊的coinbase交易作出新的承諾，以促進Neutrino的發展，這需要軟分叉。&lt;/p&gt;

&lt;h2 id=&quot;這對您意味著什麼&quot;&gt;這對您意味著什麼&lt;/h2&gt;
&lt;p&gt;事實證明Neutrino不僅對Bitcoin錢包有用，對 Lightning 也有用。當前很難設置一個Lightning節點，部分原因是您必須運行一個需要很長時間才能同步的完整節點。Neutrino在btcd中可用，但在Bitcoin Core中尚不可用，因此在Bitcoin Core中可用之前，輕型錢包將很難找到要從中獲取數據的節點。正是由於這個原因，Wasabi必須使用類似的&lt;a href=&quot;https://medium.com/@nopara73/wasabi-privacy-focused-bitcoin-wallet-for-desktop-3962d567045a&quot;&gt;超壓縮區塊數據製作自己的server&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一旦Neutrino到達Bitcoin Core，Lightning Wallets將能夠更輕鬆地作為輕client運行。這意味著您的Bitcoin錢包將在保護隱私方面更加有效。這並不意味著您將具有完全的匿名性，尤其是從鏈分析的角度而言，但是您將能夠在不儲存、傳輸或驗證整個區塊鏈的情況下實現整個節點當前享有的大部分隱私。&lt;/p&gt;

&lt;p&gt;隱私洩漏最終是安全洩漏，因為有關您的訊息可能會被用來對您不利。&lt;/p&gt;

&lt;p&gt;與使用Neutrino協議的錢包進行交易意味著，無論是在鏈上還是在Lightning Network上，您的Bitcoin交易都不太容易受到訊息洩露的影響。&lt;/p&gt;

&lt;h2 id=&quot;更多訊息&quot;&gt;更多訊息&lt;/h2&gt;
&lt;p&gt;對於對此技術感興趣的開發人員，&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki&quot;&gt;BIP0157&lt;/a&gt; and &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki&quot;&gt;BIP0158&lt;/a&gt;詳細說明了該協議，並且可從&lt;a href=&quot;https://lightning.engineering/&quot;&gt;Lightning Labs&lt;/a&gt;的開發人員處獲得&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0158/testnet-19.json&quot;&gt;test vectors&lt;/a&gt;。對於消費者，請詢問您的錢包提供商是否計劃實施Neutrino。&lt;/p&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;Neutrino是一項早就應該過期的技術。大多數使用輕型節點軟體的人都必須在某種程度上信任外部方，這不是密碼龐克的理想。通過使用Neutrino，錢包開發人員現在將能夠創建真正獨立的並且不需要信任server的錢包。&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">如今， Lightning 風行一時，儘管這是一個令人興奮的發展，但用戶目前必須運行一個完整的節點才能進行交易。在本文中，將介紹Neutrino，這是一種新的協議，用於輕型client在保留隱私且不信任中央server的情況下獲取所需的數據。原文</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/123.png" /></entry><entry><title type="html">使用x-only的Pubkey減少比特幣交易大小</title><link href="http://localhost:4000/news/2019/11/07/%E4%BD%BF%E7%94%A8x-only%E7%9A%84Pubkey%E6%B8%9B%E5%B0%91%E6%AF%94%E7%89%B9%E5%B9%A3%E4%BA%A4%E6%98%93%E5%A4%A7%E5%B0%8F/" rel="alternate" type="text/html" title="使用x-only的Pubkey減少比特幣交易大小" /><published>2019-11-07T00:00:00+08:00</published><updated>2019-11-07T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/07/%E4%BD%BF%E7%94%A8x-only%E7%9A%84Pubkey%E6%B8%9B%E5%B0%91%E6%AF%94%E7%89%B9%E5%B9%A3%E4%BA%A4%E6%98%93%E5%A4%A7%E5%B0%8F</id><content type="html" xml:base="http://localhost:4000/news/2019/11/07/%E4%BD%BF%E7%94%A8x-only%E7%9A%84Pubkey%E6%B8%9B%E5%B0%91%E6%AF%94%E7%89%B9%E5%B9%A3%E4%BA%A4%E6%98%93%E5%A4%A7%E5%B0%8F/">&lt;p&gt;&lt;strong&gt;如何使用BIP-schnorr安全地為每個output節省四個權重單位   &lt;br /&gt;
&lt;a href=&quot;https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7&quot;&gt;原文 : Reducing Bitcoin Transaction Sizes with x-only Pubkeys&lt;/a&gt;&lt;/strong&gt;  &lt;br /&gt;
8 min read   &lt;em&gt;By Jonas Nick&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/110.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;介紹--introduction&quot;&gt;介紹 | Introduction&lt;/h1&gt;

&lt;p&gt;本文是關於最近在比特幣改進提案&lt;em&gt;BIP-schnorr&lt;/em&gt;中引入所謂的x-only pubkeys。 BIP定義了針對比特幣的Schnorr簽名的介紹。&lt;/p&gt;

&lt;p&gt;與現有的比特幣（ECDSA）簽名方案相比，Schnorr簽名具&lt;a href=&quot;https://hackernoon.com/a-brief-intro-to-bitcoin-schnorr-multi-signatures-b9ef052374c5&quot;&gt;有提供各種好處的潛力&lt;/a&gt;，特別是對於典型交易而言，交易大小（和&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki&quot;&gt;&lt;em&gt;權重&lt;/em&gt;&lt;/a&gt;）更小。之所以能夠做到這一點，部分是因為Schnorr簽名支持更輕鬆地將多個簽名聚合到單個簽名中。&lt;/p&gt;

&lt;p&gt;使用 x-only pubkeys，我們可以進一步優化，在不損失安全性的前提下，顯著降低了每個交易output的權重。&lt;/p&gt;

&lt;h1 id=&quot;背景--background&quot;&gt;背景 | Background&lt;/h1&gt;

&lt;p&gt;通過從比特幣當前使用的壓縮public key中刪除Y坐標 byte，public key最終以32-byte表示。 我們將研究它的工作原理，為什麼有用，並概述安全性證明(security proof)。&lt;/p&gt;

&lt;p&gt;草繪安全證明(Sketching a security proof)是一種通常可用於比特幣和閃電協議研究的技術。 它將證明丟棄的 byte&lt;em&gt;不會&lt;/em&gt;削弱安全性，甚至不會降低”single bit”的安全性。&lt;/p&gt;

&lt;p&gt;為了使這篇文章保持小巧美觀，我們在形式上將不做任何精確說明。 本文的主要目的是對BIP-schnorr的 x-only 部分提供基本了解。&lt;/p&gt;

&lt;p&gt;本文假定已啟動&lt;a href=&quot;https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki&quot;&gt;BIP-taproot&lt;/a&gt;軟分叉，它定義了SegWit 在 version 1 output花費的規則。 我們不在乎新的output花費的規則是什麼，除了，新規則之一是允許使用BIP-schnorr中定義的Schnorr簽名進行消費。 需要指出的是，BIP只是建議，因此不能保證BIP-taproot會以其當前形式或完全啟動。&lt;/p&gt;

&lt;p&gt;首先，讓我們看一下今天壓縮後的public key如何在比特幣中工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/111.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;壓縮public key&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;比特幣中的壓縮public key是byte  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;後跟一個32 byte矩陣，或者是byte  &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;後跟一個 32 byte矩陣。 第一個 byte 稱為&lt;em&gt;tie breaker(決勝局)&lt;/em&gt;，第二個部分為橢圓曲線上基礎點的X坐標。&lt;/p&gt;

&lt;h2 id=&quot;tie-breaker的目的是什麼&quot;&gt;Tie breaker的目的是什麼？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/112.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;tie breaker的目的&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;public key在橢圓曲線上編碼一個點。 僅給出X坐標，曲線上就存在兩個點。 tie breaker的目的是確定兩個點中的哪一個被編碼為&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;  or  &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最近，BIP-Schnorr從使用壓縮的public key更改為僅使用&lt;em&gt;x-only public keys&lt;/em&gt;。 不同之處在於tie breake不再是public key的一部分。 而是隱式地假設tie breaker為&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。 實際上，在BIP中使用了一個不同的tie breaker，但這對於本文而言並不重要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/113.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;BIP-schnorr中的x-only pubkeys&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;那為什麼行得通呢？ 畢竟，&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;  and  &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;仍然是不同的點。 由secret key &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;生成的public key點&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;是group&lt;code class=&quot;highlighter-rouge&quot;&gt;G&lt;/code&gt;的生成者的&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;倍。 public key&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;的secret key是&lt;code class=&quot;highlighter-rouge&quot;&gt;-x&lt;/code&gt;。 答案是我們只需要在正確的時間否定public key和secret key即可。 特別是，簽名演算法會檢查您是否在簽名正確的public key，並在必要時取消secret key。&lt;/p&gt;

&lt;p&gt;請務必注意，錢包開發人員無需採取任何措施。 它應該由基礎crypto library處理。 BIP32分層確定性錢包生成也像以前一樣工作，只是您丟棄了第一個byte。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/114.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;為什麼我們可以刪除tie breaker?&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;為什麼引入-x-only-pubkeys&quot;&gt;為什麼引入 x-only pubkeys?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/115.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;為什麼 x-only?&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;首先，在權重單位方面，scriptPubKey的bytes非常昂貴：x-only 可以在平均完整塊中節省約0.7％的權重單位。 其次，發件人創建scriptPubKey的成本與136個權重單位中的pay-to-witness-script-hash相同。 從理論上講，如果Taproot的價格比舊版隔離見證的價格高，則採用它的速度會更慢。&lt;/p&gt;

&lt;p&gt;其次，發起人創建scriptPubKey的成本與pay-to-witness-script-hash”中的136權重單位相同。 從理論上講，如果Taproot的價格比舊的“隔離見證版本”貴，則採用它的速度會更慢。&lt;/p&gt;

&lt;p&gt;Pay-to-witness-pub-key-hash scriptPubKey的權重仍遠小於Taprootoutput，因為它們僅包含20-byte hashed public key，但這對於Taproot來說是不安全的。&lt;/p&gt;

&lt;p&gt;只是為了完整說明，如果我們考慮take the witness weight into account，Taproot和pay to witness pubkey hash非常相似。&lt;/p&gt;

&lt;h1 id=&quot;proof-sketch&quot;&gt;Proof sketch&lt;/h1&gt;

&lt;p&gt;現在讓我們看一下為什麼這是安全的。&lt;/p&gt;

&lt;p&gt;我們知道的是，在隨機預言模型中，如果離散對數問題很困難，那麼Schnorr簽名是安全的。
這意味著在不知道secret key的情況下無法偽造簽名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/116.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我們要證明的是帶有壓縮public key的Schnorr簽名是否安全，那麼x-only的Schnorr簽名是安全的。 或等效地，如果x-only的Schnorr簽名不安全，則Schnorr簽名不安全。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/117.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，我們假設存在一種偽造Schnorr簽名的演算法，如下圖右圖所示。&lt;/p&gt;

&lt;p&gt;Schnorr 簽名是一個元組。 第一個元素是稱為的public nonce，它是通過將secret nonce與group generator相乘而生成的。
第二個元素結合了secret nonce和secret key  &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;。 這裡唯一重要的部分是Schnorr簽名涉及一些hash計算。 我們現在假設的是，在某些時候，偽造者必須計算hash值-沒有其他方法可以產生偽造品。 為了在形式證明(formal proof)中正確定義此值，將hash函數替換為稱為&lt;em&gt;Random Oracle&lt;/em&gt;的理想設備。 為了方便說明，我們將繼續稱他為hash function。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/118.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;偽造者的Proof sketch模型&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;現在，我們要做的是構建一種演算法，該演算法響應提供了壓縮public key的挑戰者，並期望獲得Schnorr簽名偽造作為回報。 我們將以某種方式利用x-only的Schnorr簽名偽造者。 這只是一種演算法，如果您願意，我們可以在虛擬機上運行它。 此外，我們可以修補計算hash函數的偽造者程式碼，以返回所需的任何內容。 替換的hash函數必須隨機尋找x-only的Schnorr簽名偽造者，因為否則它可以檢測到它在模擬中並且行為不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/119.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;Proof sketch 概述&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;現在，讓我們看一下第一種情況，即public key的第一個byte為&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，，這與我們隱含地假定為x-only pubkeys相同。 在這種情況下，我們只需要刪除第一個byte，將其傳遞給偽造者，讓它做事情，然後將Schnorr簽名傳遞給挑戰者即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/120.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;Proof sketch case 1&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;在另一種情況下，第一個byte為&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;。 同樣，我們將不帶第一個byte的pubkey傳遞給偽造者，但是現在x-only偽造者會將public key解碼為&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;，因此將創建的簽名將用於錯誤的public key。 我們通過對hash函數進行編程來解決此問題，以返回挑戰者使用的hash函數output的負數。 然後，我們僅等待偽造者的答复並將其傳遞給挑戰者。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/121.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;Proof sketch case 2&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;取反的hash值會為該取反的點生成Schnorr簽名，因此挑戰者將很樂意接受該簽名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/122.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;Proof sketch resolution&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;總而言之，我們顯示的是，如果存在x-only Schnorr簽名偽造者，則存在壓縮的pubkey Schnorr簽名偽造者，或者等效地，我們可以假設x-only Schnorr簽名偽造者是安全的。&lt;/p&gt;

&lt;p&gt;我們還顯示了一些不直觀的事實，即破壞x-only的難度等於破壞壓縮的public key簽名方案。 簡而言之，tie breaker從來沒有在方案的安全性上添加任何內容。 攻擊者可以根據需要在應用x-only攻擊之前簡單地否定密鑰。 與分組操作（在這種情況下為點加法）相比，當確定攻擊的難度時，該操作通常被計數，否定操作是微不足道的。 在secp256k1的情況下，它只是對場序取模的整數（Y坐標）的取反，接近2²⁵⁶。 在任何現代處理器上，這幾乎不需要時間（在我的筆記本電腦上只需幾納秒），這意味著在硬度上的差異可以忽略不計。&lt;/p&gt;

&lt;h1 id=&quot;結論--conclusion&quot;&gt;結論 | Conclusion&lt;/h1&gt;

&lt;p&gt;總結，&lt;a href=&quot;https://github.com/bitcoin-core/secp256k1/pull/558&quot;&gt;BIP-schnorr&lt;/a&gt;和&lt;a href=&quot;https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki&quot;&gt;BIP-taproot&lt;/a&gt;最近（2019年9月）進行了調整，以使用32 byte的x-only public keys。 如果在比特幣上採用Schnorr簽名，這將進一步優化已經很低的交易權重。&lt;/p&gt;

&lt;p&gt;這種變化的程度相對較低，並且錢包開發人員不必對此太在意。 使用壓縮密鑰可以將x-only Schnorr signatures的安全性降低為Schnorr signatures。&lt;/p&gt;

&lt;p&gt;BIP-schnorr和BIP-taproot從草稿狀態到提案狀態正在逐漸成熟。 我們正在尋找反饋，因此可以隨時閱讀，實施BIP或試用BIP-schnorr和BIP-taproot的實施。 Optech Taproot研討會和Taproot評論俱樂部提供的Jupyter筆記本是用於了解有關BIP的很好的資源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BIP-schnorr and BIP-taproot are slowly maturing from the draft status to the proposal status. We’re looking for feedback, so feel free to read the BIPs, implement them, or play with implementations of &lt;a href=&quot;https://github.com/bitcoin-core/secp256k1/pull/558&quot;&gt;BIP-schnorr&lt;/a&gt; and &lt;a href=&quot;https://github.com/sipa/bitcoin/commits/taproot&quot;&gt;BIP-taproot&lt;/a&gt;. Very good resources for learning more about the BIPs are &lt;a href=&quot;https://github.com/bitcoinops/taproot-workshop&quot;&gt;this Jupyter notebook&lt;/a&gt; from the Optech Taproot workshop and the &lt;a href=&quot;https://github.com/ajtowns/taproot-review&quot;&gt;Taproot Review Club.&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">如何使用BIP-schnorr安全地為每個output節省四個權重單位 原文 : Reducing Bitcoin Transaction Sizes with x-only Pubkeys 8 min read By Jonas Nick</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/110.png" /></entry><entry><title type="html">媒體區塊鏈的調查</title><link href="http://localhost:4000/news/2019/10/31/%E7%BF%BB%E8%AD%AF-%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E8%AA%BF%E6%9F%A5/" rel="alternate" type="text/html" title="媒體區塊鏈的調查" /><published>2019-10-31T00:00:00+08:00</published><updated>2019-10-31T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/10/31/%E7%BF%BB%E8%AD%AF:%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E8%AA%BF%E6%9F%A5</id><content type="html" xml:base="http://localhost:4000/news/2019/10/31/%E7%BF%BB%E8%AD%AF-%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E8%AA%BF%E6%9F%A5/">&lt;blockquote&gt;
  &lt;p&gt;本篇文章翻譯自 &lt;a href=&quot;https://ieeexplore.ieee.org/document/8706434&quot;&gt;IEEE - A blockchain for media: Survey&lt;/a&gt; 的內容，時常我們都在想區塊鏈部署文字上的問題，但都沒有人去思考過「媒體」：圖像、影像…等的發展性，或許現今的區塊鏈並不適合存放大量的資料，但現今可以透過 IPFS .. 等工具幫助部署內容至區塊鏈上，已達到目的性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;摘要&quot;&gt;摘要&lt;/h1&gt;

&lt;p&gt;隨著互聯網的發展，媒體傳播服務已經普及。然而，傳播系統有很多問題。區塊鏈科技可以解決這些問題。在本論文中，區塊鏈會被定義為媒體區塊鏈且分成兩類。一是內文的安全性，意指將用區塊鏈保障安全性。二則是內文的權利資訊，意指將用區塊鏈追蹤和管理權利上的資訊。我們將會介紹和分析這個媒體區塊鏈。&lt;/p&gt;

&lt;h1 id=&quot;第一章節---介紹&quot;&gt;第一章節 - 介紹&lt;/h1&gt;

&lt;p&gt;隨著互聯網劇烈的發展，許多的傳播媒體服務已經提供。傳播媒體系統有著許多的問題。因為創建一個媒體的副本是簡單的，且此媒體可以被修改過，導致傳播盜竊或未經授權的媒體變得更容易。此外，版權的問題是十分嚴重的。因為這些問題，已經研究了多樣性方法，中心化管理系統無法解決這些問題。&lt;/p&gt;

&lt;p&gt;區塊鏈科技可以解決這些問題。此科技不需要中心化的伺服器和網路參與者的可靠性。一個稱作是區塊鏈的共享和分散式的資料庫儲存稱為數據的交易。區塊將鏈接到前一個區塊，每個區塊包含區塊鏈中一筆貨多筆的交易。要添加新的區塊，需要參與者之間達成共識。此結構含有許多的屬性：透明性、安全性（保障）、安全性、分散性等。具有這些特徵和特性的區塊鏈技術是保護媒體所必需的。&lt;/p&gt;

&lt;p&gt;論文中其餘的部分如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第二章節將介紹媒體的區塊鏈&lt;/li&gt;
  &lt;li&gt;第三章節將對第二章節中介紹的區塊鏈進行了分析&lt;/li&gt;
  &lt;li&gt;第四章節將對媒體區塊鏈做個總結。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第二章節---媒體區塊鏈&quot;&gt;第二章節 - 媒體區塊鏈&lt;/h1&gt;

&lt;p&gt;在本文中，我們將數位內容、媒體和多媒體的區塊鏈定義為&lt;strong&gt;媒體區塊鏈&lt;/strong&gt;。關於媒體區塊鏈有很多研究。這些研究可確保數位內容的完整性、可追溯性、驗證或控制，並分為兩類：一是內文的安全性意味著使用區塊鏈保護內容。二是內容權利資訊，這意指將使用區塊鏈追蹤和管理權利資訊。&lt;/p&gt;

&lt;h2 id=&quot;a-內文安全性&quot;&gt;A. 內文安全性&lt;/h2&gt;

&lt;p&gt;D. Bhowmik and T. Feng [1] 提出了一個多媒體區塊鏈框架來針對圖像媒體的分散式多媒體之安全性和完整性。提出的框架包含基於壓縮感測（CS）[4]的自嵌入浮水印演算法[5]，區塊鏈分散式帳本和身份驗證。基於 CS 的自嵌入浮水印可以檢查媒體是否遭篡改。使用 CS 從原本的資料提取浮水印。CS 也可以用於恢復原始資料。在區塊鏈中，交易由包含交易 ID 的圖像/媒體的交易訊息和可以恢復原始資料的 CS 樣本訊息組成。認證過程如下。從想要驗證的圖像中提取浮水印。如上所述，內含浮水印的交易包含交易 ID 和 CS 樣本。區塊鏈可以透過交易 ID 查詢交易細節。並透過 CS 樣本恢復原始圖像。將檢索到的圖像與原始圖像進行比較，我們可以確定修改後的區域。&lt;/p&gt;

&lt;p&gt;在[2]中，Fotiou. N 和 Polyzos. G.C. 考慮如何在以訊息為中心的網路（ICN）中傳播內容[9]。該系統的模型由內容所有者和訂閱用戶所組成。
作者使用基於區塊鏈的分層身份的加密（HIBE）[7]演算法。此演算法可確保內容完整性和內容之來源驗證。HIBE 是使用身份作為公鑰的方案而 PKG 有嚴重的金鑰託管問題。因此，使用區塊鏈來解決這個問題，可以透過 HIBE 的公鑰和私鑰安全地傳播內容。&lt;/p&gt;

&lt;h2 id=&quot;b-內文權利資訊&quot;&gt;B. 內文權利資訊&lt;/h2&gt;

&lt;p&gt;在[3]中，作者提出了中國網路媒體行業的五個問題：抄襲、網路媒體質量低、利潤低、法規少和版權交易不受控制。為了解決這些問題，他們提出了一種基於區塊鏈的網路媒體版權管理方案。該方案具有生產管理，版權訊息管理，交易管理和用戶行為管理。在生產管理上，儲存數據並建立智能合約，在版權訊息管理上，版權會受到控制。此外，該方案表示提供方與平台方之間的關係以提高工作質量，交易已生成並在事務管理中簽名。透過允許客戶對問題進行投票及用戶活動管理接受公眾意見，這些管理將保護數字版權。&lt;/p&gt;

&lt;p&gt;J. Kishigami 提出了超級傳播[8]的問題，該問題應集中於中心。為了解決這個問題，作者提出了使用區塊鏈的內容傳播系統[4]，所提出的系統具有三個特徵。首先，內容擁有者可以輕鬆控制其內容。第二，區塊鏈是為此系統設計的。第三，目標是稱為 4K 或 8K 的超高分辨率視頻。他的系統由許可方，被許可方和礦工組成。許可方有權控制僅擁有的內容並上傳該內容。被許可方運行兩個應用程序。一個應用程序從區塊鏈獲得許可證後另一個應用程序播放視頻，挖礦服務器生成一個包含權利資訊的區塊，並通過共識演算法將該區塊添加到區塊鏈中，因此系統不需要一個中央伺服器。&lt;/p&gt;

&lt;h1 id=&quot;第三章節---分析&quot;&gt;第三章節 - 分析&lt;/h1&gt;

&lt;p&gt;在本章節中，我們分析第二章節中介紹的媒體區塊鏈，並通過 TABLE1 比較媒體區塊鏈。它顯示了交易中顯示的配置，使用的區塊鏈類型以及對媒體的保證。在內容安全方面，媒體區塊鏈具有不同的交易配置和對媒體的類似保證。另一方面，內容權利訊息中的媒體區塊鏈具有類似的交易配置和對媒體的不同保證。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/92.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;第四章節---結論&quot;&gt;第四章節 - 結論&lt;/h1&gt;

&lt;p&gt;隨著互聯網的日益發展，媒體存在許多問題。區塊鏈解決了這些問題。我們將其定義為媒體區塊鏈，並在第二章節中介紹了有關媒體區塊鏈的四項研究。這些研究分為兩類：內容安全性和內容權利資訊。在第三章節中，我們對每個媒體鏈進行了比較，以顯示交易中配置，區塊鏈使用的類型以及對媒體的保證。我們通過此比較分析了每個區塊鏈。&lt;/p&gt;

&lt;p&gt;雖說媒體區塊鏈還不熟悉。但是，人們很感興趣，因為媒體區塊鏈可以解決現有媒體中竊盜、版權、未經授權的發行等問題。未來將有許多關於媒體區塊鏈的研究。&lt;/p&gt;

&lt;h1 id=&quot;譯者後記&quot;&gt;譯者後記&lt;/h1&gt;

&lt;p&gt;近期區塊鏈的應用上除了博弈（將規則公開透明吸引玩家和莊家進場遊玩。）、文字上鏈（確保不會被中心伺服器刪除。）、各式履歷（透過公開透明的規則，保障雙方權益。）..等，但媒體區塊鏈的概念尚未萌芽，有幾個痛點（以太坊區塊鏈為例）：1. 部署一張照片需要過多的成本（Gas Fees 太高）2. 上傳速度太慢、部署時間太久 ..等，以現有要解決這些問題仍必須透過 IPFS 來完成部署至區塊鏈上之動作，希望未來能夠將&lt;strong&gt;擴容性&lt;/strong&gt;和 &lt;strong&gt;TPS 提高&lt;/strong&gt;，使得應用區塊鏈項目更加方便。&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;D Bhowmik, T. Feng, “The multimedia blockchain: A distributed and tamper-proof media transaction framework”, Digital Signal Processing (DSP) 2017 22nd International Conference on, 2017.&lt;/li&gt;
  &lt;li&gt;N Fotiou, G.C. Polyzos, “Decentralized name-based security for content distribution using blockchains”, Computer Communications Workshops (INFOCOM WKSHPS) 2016 IEEE Conference on, 2016.&lt;/li&gt;
  &lt;li&gt;R Xu, L Zhang, H Zhao, Y. Peng, “Design of network media’s digital rights management scheme based on blockchain technology”, Autonomous Decentralized System (ISADS) 2017 IEEE 13th International Symposium on, 2017.&lt;/li&gt;
  &lt;li&gt;J Kishigami, S Fujimura, H Watanabe, A Nakadaira, A Akutsu, “The blockchain-based digital content distribution system”, Big Data and Cloud Computing (BDCloud) 2015 IEEE Fifth International Conference on, 2015.&lt;/li&gt;
  &lt;li&gt;D.L. Donoho, “Compressed sensing”, IEEE Transactions on information theory, vol. 52.4, pp. 1289-1306, 2006.&lt;/li&gt;
  &lt;li&gt;D Singh, S.K. Singh, “Effective self-embedding watermarking scheme for image tampered detection and localization with recovery capability”, Journal of Visual Communication and Image Representation, vol. 38, pp. 775-789, 2016.&lt;/li&gt;
  &lt;li&gt;A Lewko, B Waters, “Unbounded HIBE and attribute-based encryption”, Annual International Conference on the Theory and Applications of Cryptographic Techniques, 2011.&lt;/li&gt;
  &lt;li&gt;R Mori, M Kawahara, “Superdistribution: the concept and the architecture”, IEICE TRANSACTIONS (1976–1990), vol. 73.7, pp. 1133-1146, 1990.&lt;/li&gt;
  &lt;li&gt;B Ahlgren, C Dannewitz, C Imbrenda, D Kutscher, B Ohlman, “A survey of information-centric networking”, IEEE Communications Magazine, vol. 50.7, 2012.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">本篇文章翻譯自 IEEE - A blockchain for media: Survey 的內容，時常我們都在想區塊鏈部署文字上的問題，但都沒有人去思考過「媒體」：圖像、影像…等的發展性，或許現今的區塊鏈並不適合存放大量的資料，但現今可以透過 IPFS .. 等工具幫助部署內容至區塊鏈上，已達到目的性。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/92.png" /></entry></feed>